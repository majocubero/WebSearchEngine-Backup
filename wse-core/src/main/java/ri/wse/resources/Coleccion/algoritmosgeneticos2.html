<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.70)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Algoritmos gen&#233;ticos y computaci&#243;n evolutiva</TITLE>
<META NAME="description" CONTENT="Algoritmos gen&#233;ticos y computaci&#243;n evolutiva">
<META NAME="keywords" CONTENT="algen">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="algen.css">

</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive" SRC="nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev_g.png">   
<BR>
<BR><BR></DIV>
<!--End of Navigation Panel-->

<P>

<P>

<P>

<P>
<H1 ALIGN="CENTER">Algoritmos gen&#233;ticos y computaci&#243;n evolutiva</H1><DIV CLASS="author_info">

<P ALIGN="CENTER"><STRONG>Adam Marczyk</STRONG></P>
<P ALIGN="CENTER"><STRONG>2004</STRONG></P>
</DIV>

<H3>Resumen:</H3>
<DIV CLASS="ABSTRACT">
Los creacionistas afirman a menudo que el proceso evolutivo no puede
crear informaci&#243;n nueva, o que la evoluci&#243;n no posee beneficios pr&#225;cticos.
Este art&#237;culo refuta esas afirmaciones describiendo el crecimiento
explosivo y las extensas aplicaciones de los algoritmos gen&#233;ticos,
una t&#233;cnica de computaci&#243;n basada en los principios de la evoluci&#243;n
biol&#243;gica.
</DIV>
<P>

<P>

<H1><A NAME="SECTION00010000000000000000">
Introducci&#243;n</A>
</H1>

<P>
De vez en cuando, los creacionistas acusan a la evoluci&#243;n de que carece
de utilidad como teor&#237;a cient&#237;fica porque no produce beneficios pr&#225;cticos
y no tiene relevancia en la vida diaria. Sin embargo, tan s&#243;lo la
evidencia de la biolog&#237;a demuestra que esta afirmaci&#243;n es falsa. Hay
numerosos fen&#243;menos naturales para los que la evoluci&#243;n nos ofrece
un s&#243;lido fundamento te&#243;rico. Por nombrar uno, el desarrollo observado
de la resistencia -a los insecticidas en las plagas de cultivos,
a los antibi&#243;ticos en las bacterias, a la quimioterapia en las c&#233;lulas
cancerosas, y a los f&#225;rmacos antiretrovirales en virus como el VIH-
es una consecuencia abierta de las leyes de la mutaci&#243;n y la selecci&#243;n,
y comprender estos principios nos ha ayudado a desarrollar estrategias
para enfrentarnos a estos nocivos organismos. El postulado evolutivo
de la descendencia com&#250;n ha ayudado al desarrollo de nuevos medicamentos
y t&#233;cnicas, al proporcionar a los investigadores una buena idea de
con qu&#233; organismos deben experimentar para obtener resultados que
probablemente ser&#225;n relevantes para los seres humanos. Finalmente,
el hombre ha utilizado con grandes resultados el principio de cr&#237;a
selectiva para crear organismos personalizados, distintos a cualquiera
que se pueda encontrar en la naturaleza, para beneficio propio. El
ejemplo can&#243;nico, por supuesto, es la diversidad de variedades de
perros dom&#233;sticos (razas tan diversas como los bulldogs, chihuahuas
y dachshunds han sido producidas a partir de lobos en s&#243;lo unos pocos
miles de a&#241;os), pero ejemplos menos conocidos incluyen al ma&#237;z cultivado
(muy diferente de sus parientes salvajes, que carecen de las familiares
``orejas'' del ma&#237;z cultivado), a los peces de colores (como los perros,
hemos criado variedades cuyo aspecto es dr&#225;sticamente distinto al
del tipo salvaje), y a las vacas lecheras (con ubres inmensas, mucho
mayores que las necesarias para alimentar a una cr&#237;a).

<P>
Los cr&#237;ticos pueden argumentar que los creacionistas pueden explicar
estas cosas sin recurrir a la evoluci&#243;n. Por ejemplo, a menudo los
creacionistas explican el desarrollo de la resistencia a los agentes
antibi&#243;ticos en las bacterias, o los cambios forjados en los animales
dom&#233;sticos por selecci&#243;n artificial, asumiendo que Dios decidi&#243; crear
a los organismos en grupos fijos, llamados ``tipos'' o baramins. Aunque
la microevoluci&#243;n natural o la selecci&#243;n artificial dirigida por humanos
pueden producir diferentes variedades dentro de los ``tipo-perro'',
``tipo-vaca'' o ``tipo-bacteria'' (!) creados originalmente, ninguna
cantidad de tiempo o cambio gen&#233;tico puede transformar un ``tipo''
en otro. Sin embargo, nunca se explica c&#243;mo determinan los creacionistas
lo que es un ``tipo'', o qu&#233; mecanismo impide a los seres vivos evolucionar
m&#225;s all&#225; de sus l&#237;mites.

<P>
Pero en las &#250;ltimas d&#233;cadas, el continuo avance de la tecnolog&#237;a moderna
ha producido algo nuevo. Ahora la evoluci&#243;n est&#225; produciendo beneficios
pr&#225;cticos en un campo muy distinto y, esta vez, los creacionistas
no pueden afirmar que su explicaci&#243;n se adapte a los hechos igual
de bien. Este campo es la inform&#225;tica, y los beneficios provienen
de una estrategia de programaci&#243;n llamada algoritmos gen&#233;ticos. Este
ensayo explicar&#225; qu&#233; son los algoritmos gen&#233;ticos y mostrar&#225; de qu&#233;
manera son relevantes en el debate evoluci&#243;n/creacionismo.

<P>

<H1><A NAME="SECTION00020000000000000000">
&#191;Qu&#233; es un algoritmo gen&#233;tico?</A>
</H1>

<P>
Expuesto concisamente, un algoritmo gen&#233;tico (o AG para abreviar)
es una t&#233;cnica de programaci&#243;n que imita a la evoluci&#243;n biol&#243;gica
como estrategia para resolver problemas. Dado un problema espec&#237;fico
a resolver, la entrada del AG es un conjunto de soluciones potenciales
a ese problema, codificadas de alguna manera, y una m&#233;trica llamada
funci&#243;n de aptitud que permite evaluar cuantitativamente a cada candidata.
Estas candidatas pueden ser soluciones que ya se sabe que funcionan,
con el objetivo de que el AG las mejore, pero se suelen generar aleatoriamente.

<P>
Luego el AG eval&#250;a cada candidata de acuerdo con la funci&#243;n de aptitud.
En un acervo de candidatas generadas aleatoriamente, por supuesto,
la mayor&#237;a no funcionar&#225;n en absoluto, y ser&#225;n eliminadas. Sin embargo,
por puro azar, unas pocas pueden ser prometedoras -pueden mostrar
actividad, aunque s&#243;lo sea actividad d&#233;bil e imperfecta, hacia la
soluci&#243;n del problema.

<P>
Estas candidatas prometedoras se conservan y se les permite reproducirse.
Se realizan m&#250;ltiples copias de ellas, pero las copias no son perfectas;
se introducen cambios aleatorios durante el proceso de copia. Luego,
esta descendencia digital prosigue con la siguiente generaci&#243;n, formando
un nuevo acervo de soluciones candidatas, y son sometidas a una ronda
de evaluaci&#243;n de aptitud. Las candidatas que han empeorado o no han
mejorado con los cambios en su c&#243;digo son eliminadas de nuevo; pero,
de nuevo, por puro azar, las variaciones aleatorias introducidas en
la poblaci&#243;n pueden haber mejorado a algunos individuos, convirti&#233;ndolos
en mejores soluciones del problema, m&#225;s completas o m&#225;s eficientes.
De nuevo, se selecionan y copian estos individuos vencedores hacia
la siguiente generaci&#243;n con cambios aleatorios, y el proceso se repite.
Las expectativas son que la aptitud media de la poblaci&#243;n se incrementar&#225;
en cada ronda y, por tanto, repitiendo este proceso cientos o miles
de rondas, pueden descubrirse soluciones muy buenas del problema.

<P>
Aunque a algunos les puede parecer asombroso y antiintuitivo, los algoritmos
gen&#233;ticos han demostrado ser una estrategia enormemente poderosa y
exitosa para resolver problemas, demostrando de manera espectacular
el poder de los principios evolutivos. Se han utilizado algoritmos
gen&#233;ticos en una amplia variedad de campos para desarrollar soluciones
a problemas tan dif&#237;ciles o m&#225;s dif&#237;ciles que los abordados por los
dise&#241;adores humanos. Adem&#225;s, las soluciones que consiguen son a menudo
m&#225;s eficientes, m&#225;s elegantes o m&#225;s complejas que nada que un ingeniero
humano producir&#237;a. &#161;En algunos casos, los algoritmos gen&#233;ticos han
producido soluciones que dejan perplejos a los programadores que escribieron
los algoritmos en primera instancia!

<P>

<H2><A NAME="SECTION00021000000000000000">
M&#233;todos de representaci&#243;n</A>
</H2>

<P>
Antes de que un algoritmo gen&#233;tico pueda ponerse a trabajar en un
problema, se necesita un m&#233;todo para codificar las soluciones potenciales
del problema de forma que una computadora pueda procesarlas. Un enfoque
com&#250;n es codificar las soluciones como cadenas binarias: secuencias
de 1s y 0s, donde el d&#237;gito de cada posici&#243;n representa el valor de
alg&#250;n aspecto de la soluci&#243;n. Otro m&#233;todo similar consiste en codificar
las soluciones como cadenas de enteros o n&#250;meros decimales, donde
cada posici&#243;n, de nuevo, representa alg&#250;n aspecto particular de la
soluci&#243;n. Este m&#233;todo permite una mayor precisi&#243;n y complejidad que
el m&#233;todo comparativamente restringido de utilizar s&#243;lo n&#250;meros binarios,
y a menudo ``est&#225; intuitivamente m&#225;s cerca del espacio de problemas''
(Fleming y Purshouse 2002[<A
 HREF="algen.html#key-3">3</A>], p 1.228).

<P>
Esta t&#233;cnica se utiliz&#243;, por ejemplo, en el trabajo de Steffen Schulze-Kremer,
que escribi&#243; un algoritmo gen&#233;tico para predecir la estructura tridimensional
de una prote&#237;na, bas&#225;ndose en la secuencia de amino&#225;cidos que la componen
(Mitchell 1996[<A
 HREF="algen.html#key-47">47</A>], p. 62). El AG de Schulze-Kremer utilizaba
n&#250;meros reales para representar los famosos ``&#225;ngulos de torsi&#243;n''
entre los enlaces pept&#237;dicos que conectan a los amino&#225;cidos. (Una
prote&#237;na est&#225; formada por una secuencia de bloques b&#225;sicos llamados
amino&#225;cidos, que se conectan como los eslabones de una cadena. Una
vez que todos los amino&#225;cidos est&#225;n enlazados, la prote&#237;na se dobla
formando una compleja estructura tridimensional, basada en cu&#225;les
amino&#225;cidos se atraen entre ellos y cu&#225;les se repelen. La forma de
una prote&#237;na determina su funci&#243;n). Los algoritmos gen&#233;ticos para
entrenar a las redes neuronales tambi&#233;n utilizan a menudo este m&#233;todo
de codificaci&#243;n.

<P>
Un tercer m&#233;todo consiste en representar a los individuos de un AG
como cadenas de letras, donde cada letra, de nuevo, representa un
aspecto espec&#237;fico de la soluci&#243;n. Un ejemplo de esta t&#233;cnica es el
m&#233;todo basado en ``codificaci&#243;n gram&#225;tica'' de Hiroaki Kitano, en
el que a un AG se le encarg&#243; la tarea de evolucionar un sencillo conjunto
de reglas llamadas gram&#225;tica libre de contexto, que a su vez se utilizaban
para generar redes neuronales para una variedad de problemas (Mitchell
1996[<A
 HREF="algen.html#key-47">47</A>], p. 74).

<P>
La virtud de estos tres m&#233;todos es que facilitan la definición de
operadores que causen los cambios aleatorios en las candidatas seleccionadas:
cambiar un 0 por un 1 o viceversa, sumar o restar al valor de un n&#250;mero
una cantidad elegida al azar, o cambiar una letra por otra. (Ver la
secci&#243;n sobre los m&#233;todos de cambio para m&#225;s detalles acerca de los
operadores gen&#233;ticos). Otra estrategia, desarrollada principalmente
por John Koza, de la Universidad de Stanford, y denominada programaci&#243;n
gen&#233;tica, representa a los programas como estructuras de datos ramificadas
llamadas &#225;rboles (Koza et al. 2003[<A
 HREF="algen.html#key-42">42</A>], p. 35). En este
m&#233;todo, los cambios aleatorios pueden generarse cambiado el operador
o alterando el valor de un cierto nodo del &#225;rbol, o sustituyendo un
sub&#225;rbol por otro.

<P>

<DIV ALIGN="CENTER"><A NAME="29"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
Tres sencillos &#225;rboles de programa del tipo utilizado normalmente
en la programaci&#243;n gen&#233;tica. Debajo se proporciona la expresi&#243;n matem&#225;tica
que representa cada uno.</CAPTION>
<TR><TD><IMG
  WIDTH="613" HEIGHT="201" ALIGN="BOTTOM" BORDER="0"
 SRC="./genprogtrees.jpg"
 ALT="Image genprogtrees">

<P></TD></TR>
</TABLE>
</DIV>

<P>
Es importante se&#241;alar que los algoritmos evolutivos no necesitan representar
las soluciones candidatas como cadenas de datos de una longitud fija.
Algunos las representan de esta manera, pero otros no; por ejemplo,
la ``codificaci&#243;n gramatical'' de Kitano, explicada arriba, puede
escalarse eficientemente para crear redes neuronales grandes y complejas,
y los &#225;rboles de programaci&#243;n gen&#233;tica de Koza pueden crecer arbitrariamente
tanto como sea necesario para resolver cualquier problema que se les
pida.

<P>

<H2><A NAME="SECTION00022000000000000000">
M&#233;todos de selecci&#243;n</A>
</H2>

<P>
Un algoritmo gen&#233;tico puede utilizar muchas t&#233;cnicas diferentes para
seleccionar a los individuos que deben copiarse hacia la siguiente
generaci&#243;n, pero abajo se listan algunos de los m&#225;s comunes. Algunos
de estos m&#233;todos son mutuamente exclusivos, pero otros pueden utilizarse
en combinaci&#243;n, algo que se hace a menudo.

<P>

<UL>
<LI>Selecci&#243;n elitista: se garantiza la selección de los miembros m&#225;s aptos de cada
generaci&#243;n. (La mayor&#237;a de los AGs no utilizan elitismo
puro, sino que usan una forma modificada por la que el individuo mejor,
o algunos de los mejores, son copiados hacia la siguiente generaci&#243;n
en caso de que no surja nada mejor).
</LI>
<LI>Selecci&#243;n proporcional a la aptitud: los individuos m&#225;s aptos tienen
m&#225;s probabilidad de ser seleccionados, pero no la certeza.
</LI>
<LI>Selecci&#243;n por rueda de ruleta: una forma de selecci&#243;n proporcional
a la aptitud en la que la probabilidad de que un individuo sea seleccionado
es proporcional a la diferencia entre su aptitud y la de sus competidores.
(Conceptualmente, esto puede representarse como un juego de ruleta
-cada individuo obtiene una secci&#243;n de la ruleta, pero los m&#225;s aptos
obtienen secciones mayores que las de los menos aptos. Luego la ruleta
se hace girar, y en cada vez se elige al individuo que ``posea'' la
secci&#243;n en la que se pare la ruleta).
</LI>
<LI>Selecci&#243;n escalada: al incrementarse la aptitud media de la poblaci&#243;n,
la fuerza de la presi&#243;n selectiva tambi&#233;n aumenta y la funci&#243;n de
aptitud se hace m&#225;s discriminadora. Este m&#233;todo puede ser &#250;til para
seleccionar m&#225;s tarde, cuando todos los individuos tengan una aptitud
relativamente alta y s&#243;lo les distingan peque&#241;as diferencias en la
aptitud.
</LI>
<LI>Selecci&#243;n por torneo: se eligen subgrupos de individuos de la poblaci&#243;n,
y los miembros de cada subgrupo compiten entre ellos. S&#243;lo se elige
a un individuo de cada subgrupo para la reproducci&#243;n.
</LI>
<LI>Selecci&#243;n por rango: a cada individuo de la poblaci&#243;n se le asigna
un rango num&#233;rico basado en su aptitud, y la selecci&#243;n se basa en
este ranking, en lugar de las diferencias absolutas en aptitud. La
ventaja de este m&#233;todo es que puede evitar que individuos muy aptos
ganen dominancia al principio a expensas de los menos aptos, lo que
reducir&#237;a la diversidad gen&#233;tica de la poblaci&#243;n y podr&#237;a obstaculizar
la b&#250;squeda de una soluci&#243;n aceptable.
</LI>
<LI>Selecci&#243;n generacional: la descendencia de los individuos seleccionados
en cada generaci&#243;n se convierte en toda la siguiente generaci&#243;n. No
se conservan individuos entre las generaciones.
</LI>
<LI>Selecci&#243;n por estado estacionario: la descendencia de los individuos
seleccionados en cada generaci&#243;n vuelven al acervo gen&#233;tico preexistente,
reemplazando a algunos de los miembros menos aptos de la siguiente
generaci&#243;n. Se conservan algunos individuos entre generaciones.
</LI>
<LI>Selecci&#243;n jer&#225;rquica: los individuos atraviesan m&#250;ltiples rondas de
selecci&#243;n en cada generaci&#243;n. Las evaluaciones de los primeros niveles
son m&#225;s r&#225;pidas y menos discriminatorias, mientras que los que sobreviven
hasta niveles m&#225;s altos son evaluados m&#225;s rigurosamente. La ventaja
de este m&#233;todo es que reduce el tiempo total de c&#225;lculo al utilizar
una evaluaci&#243;n m&#225;s r&#225;pida y menos selectiva para eliminar a la mayor&#237;a
de los individuos que se muestran poco o nada prometedores, y sometiendo
a una evaluaci&#243;n de aptitud m&#225;s rigurosa y computacionalmente m&#225;s
costosa s&#243;lo a los que sobreviven a esta prueba inicial.
</LI>
</UL>

<P>

<H2><A NAME="SECTION00023000000000000000"></A><A NAME="sub:M_E9todos-de-cambio"></A><BR>
M&#233;todos de cambio
</H2>

<P>
Una vez que la selecci&#243;n ha elegido a los individuos aptos, &#233;stos
deben ser alterados aleatoriamente con la esperanza de mejorar su
aptitud para la siguiente generaci&#243;n. Existen dos estrategias b&#225;sicas
para llevar esto a cabo. La primera y m&#225;s sencilla se llama mutaci&#243;n.
Al igual que una mutaci&#243;n en los seres vivos cambia un gen por otro,
una mutaci&#243;n en un algoritmo gen&#233;tico tambi&#233;n causa peque&#241;as alteraciones
en puntos concretos del c&#243;digo de un idividuo.

<P>
El segundo m&#233;todo se llama cruzamiento, e implica elegir a dos individuos
para que intercambien segmentos de su c&#243;digo, produciendo una ``descendencia''
artificial cuyos individuos son combinaciones de sus padres. Este
proceso pretende simular el proceso an&#225;logo de la recombinaci&#243;n que
se da en los cromosomas durante la reproducci&#243;n sexual. Las formas
comunes de cruzamiento incluyen al cruzamiento de un punto, en el
que se establece un punto de intercambio en un lugar aleatorio del
genoma de los dos individuos, y uno de los individuos contribuye todo
su c&#243;digo anterior a ese punto y el otro individuo contribuye todo
su c&#243;digo a partir de ese punto para producir una descendencia, y
al cruzamiento uniforme, en el que el valor de una posici&#243;n dada en
el genoma de la descendencia corresponde al valor en esa posici&#243;n
del genoma de uno de los padres o al valor en esa posici&#243;n del genoma
del otro padre, elegido con un 50% de probabilidad.

<P>

<DIV ALIGN="CENTER">
<IMG
  WIDTH="218" HEIGHT="101" ALIGN="BOTTOM" BORDER="0"
 SRC="./crossover.jpg"
 ALT="Image crossover">

</DIV>

<DIV ALIGN="CENTER"><A NAME="40"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
Cruzamiento y mutaci&#243;n. El diagrama de arriba ilustra el efecto de
estos dos operadores gen&#233;ticos en los individuos de una poblaci&#243;n de
cadenas de 8 bits. El diagrama superior muestra a dos individuos llevando
a cabo un cruzamiento de un punto; el punto de intercambio se establece
entre las posiciones quinta y sexta del genoma, produciendo un nuevo individuo
que es h&#237;brido de sus progenitores. El segundo diagrama muestra a un individuo
sufriendo una mutaci&#243;n en la posici&#243;n 4, cambiando el 0 de esa posici&#243;n
de su genoma por un 1.</CAPTION>
<TR><TD><IMG
  WIDTH="219" HEIGHT="61" ALIGN="BOTTOM" BORDER="0"
 SRC="./mutation.jpg"
 ALT="Image mutation">

<P></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION00024000000000000000">
Otras t&#233;cnicas de resoluci&#243;n de problemas</A>
</H2>

<P>
Con el auge de la inform&#225;tica de inteligencia artificial y el desarrollo
de los m&#233;todos heur&#237;sticos, han emergido otras t&#233;cnicas de resoluci&#243;n
computerizada de problemas que en algunos aspectos son similares a
los algoritmos gen&#233;ticos. Esta secci&#243;n explica algunas de estas t&#233;cnicas,
en qu&#233; se parecen a los AGs y en qu&#233; se diferencian.

<P>

<H3><A NAME="SECTION00024100000000000000"></A><A NAME="sub:Redes-neuronales"></A><BR>
Redes neuronales
</H3>

<P>
Una red neuronal es un m&#233;todo de resoluci&#243;n de problemas basado en
un modelo inform&#225;tico de la manera en que est&#225;n conectadas las neuronas
del cerebro. Una red neuronal consiste en capas de unidades procesadoras,
llamadas nodos, unidas por conexiones direccionales: una capa de entrada,
una capa de salida y cero o m&#225;s capas ocultas enmedio. Se le presenta
un patr&#243;n inicial de entrada a la capa de entrada, y luego los nodos
que se estimulan transmiten una se&#241;al a los nodos de la siguiente
capa a la que est&#225;n conectados. Si la suma de todas las entradas que
entran en una de estas neuronas virtuales es mayor que el famoso umbral
de activaci&#243;n de la neurona, esa neurona se activa, y transmite su
propia se&#241;al a las neuronas de la siguiente capa. El patr&#243;n de activaci&#243;n,
por tanto, se propaga hacia delante hasta que alcanza a la capa de
salida, donde es devuelto como soluci&#243;n a la entrada presentada. Al
igual que en el sistema nervioso de los organismos biol&#243;gicos, las
redes neuronales aprenden y afinan su rendimiento a lo largo del tiempo,
mediante la repetici&#243;n de rondas en las que se ajustan sus umbrales,
hasta que la salida real coincide con la salida deseada para cualquier
entrada dada. Este proceso puede ser supervisado por un experimentador
humano, o puede correr autom&#225;ticamente utilizando un algoritmo de
aprendizaje (Mitchell 1996[<A
 HREF="algen.html#key-47">47</A>], p. 52). Se han utilizado
algoritmos gen&#233;ticos para construir y entrenar a redes neuronales.

<P>

<DIV ALIGN="CENTER"><A NAME="47"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
Una sencilla red neuronal anticipativa
(feedforward), con una capa consistente en cuatro neuronas, una capa
oculta consistente en tres neuronas y una capa de salida consistente
en cuatro neuronas. El n&#250;mero de cada neurona representa su umbral
de activaci&#243;n: s&#243;lo se excitar&#225; si recibe al menos esa cantidad de
entradas. El diagrama muestra c&#243;mo la red neuronal recibe una cadena
de entrada y c&#243;mo la activaci&#243;n se extiende por la red hasta producir
una salida.</CAPTION>
<TR><TD><IMG
  WIDTH="743" HEIGHT="239" ALIGN="BOTTOM" BORDER="0"
 SRC="./nn.jpg"
 ALT="Image nn">

<P></TD></TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION00024200000000000000">
Ascenso a colina (Hill Climbing)</A>
</H3>

<P>
Similares a los algoritmos gen&#233;ticos, aunque m&#225;s sistem&#225;ticos y menos
aleatorios. Un algoritmo de ascenso a colina comienza con una soluci&#243;n
al problema a mano, normalmente elegida al azar. Luego, la cadena
se muta, y si la mutaci&#243;n proporciona una soluci&#243;n con mayor aptitud
que la soluci&#243;n anterior, se conserva la nueva soluci&#243;n; en caso contrario,
se conserva la soluci&#243;n actual. Luego el algoritmo se repite hasta
que no se pueda encontrar una mutaci&#243;n que provoque un incremento
en la aptitud de la soluci&#243;n actual, y esta soluci&#243;n se devuelve como
resultado (Koza et al. 2003[<A
 HREF="algen.html#key-42">42</A>], p. 59). (Para entender
de d&#243;nde viene el nombre de esta t&#233;cnica, imagine que el espacio de
todas las soluciones posibles de un cierto problema se representa
como un paisaje tridimensional. Un conjunto de coordenadas en ese
paisaje representa una soluci&#243;n particular. Las soluciones mejores
est&#225;n a mayor altitud, formando colinas y picos; las que son peores
est&#225;n a menor altitud, formando valles. Un ``trepacolinas'' es, por
tanto, un algoritmo que comienza en un punto dado del paisaje y se
mueve inexorablemente colina arriba). El algoritmo de ascenso a colina
es lo que se conoce como algoritmo voraz, lo que significa que siempre
hace la mejor elecci&#243;n disponible en cada paso, con la esperanza de
que de esta manera se puede obtener el mejor resultado global. En
contraste, los m&#233;todos como los algoritmos gen&#233;ticos y el recocido
simulado, discutido abajo, no son voraces; a veces, estos m&#233;todos
hacen elecciones menos &#243;ptimas al principio con la esperanza de que
conducir&#225;n hacia una soluci&#243;n mejor m&#225;s adelante.

<P>

<H3><A NAME="SECTION00024300000000000000">
Recocido simulado (simulated annealing)</A>
</H3>

<P>
Otra t&#233;cnica de optimizaci&#243;n similar a los algoritmos evolutivos se
conoce como recocido simulado. La idea toma prestado su nombre del
proceso industrial en el que un material se calienta por encima de
su punto de fusi&#243;n y luego se enfr&#237;a gradualmente para eliminar defectos
en su estructura cristalina, produciendo un entramado de &#225;tomos m&#225;s
estable y regular (Haupt y Haupt 1998[<A
 HREF="algen.html#key-34">34</A>], p. 16). En el
recocido simulado, como en los algoritmos gen&#233;ticos, existe una funci&#243;n
de aptitud que define un paisaje adaptativo; sin embargo, en lugar
de una poblaci&#243;n de candidatas como en los AGs, s&#243;lo existe una soluci&#243;n
candidata. El recocido simulado tambi&#233;n a&#241;ade el concepto de ``temperatura'',
una cantidad num&#233;rica global que disminuye gradualmente en el tiempo.
En cada paso del algoritmo, la soluci&#243;n muta (lo que es equivalente
a moverse hacia un punto adyacente en el paisaje adaptativo). Luego,
la aptitud de la nueva soluci&#243;n se compara con la aptitud de la soluci&#243;n
anterior; si es mayor, se conserva la nueva soluci&#243;n. En caso contrario,
el algoritmo toma la decisi&#243;n de conservarla o descartarla en base
a la temperatura. Si la temperatura es alta, como lo es al principio,
pueden conservarse incluso cambios que causan decrementos significativos
en la aptitud, y utilizarse como base para la siguiente ronda del
algoritmo, pero al ir disminuyendo la temperatura, el algoritmo se
va haciendo m&#225;s y m&#225;s propenso a aceptar s&#243;lo los cambios que aumentan
la aptitud. Finalmente, la temperatura alzanca el cero y el sistema
se ``congela''; cualquiera que sea la configuraci&#243;n que exista en
ese punto se convierte en la soluci&#243;n. El recocido simulado tiene
a menudo aplicaciones en la ingenier&#237;a del dise&#241;o, como determinar
la disposici&#243;n f&#237;sica de los componentes en un chip inform&#225;tico (Kirkpatrick,
Gelatt y Vecchi 1983[<A
 HREF="algen.html#key-40">40</A>]).

<P>

<H1><A NAME="SECTION00030000000000000000">
Una breve historia de los AGs</A>
</H1>

<P>
Los primeros ejemplos de lo que hoy podr&#237;amos llamar algoritmos gen&#233;ticos
aparecieron a finales de los 50 y principios de los 60, programados
en computadoras por bi&#243;logos evolutivos que buscaban expl&#237;citamente
realizar modelos de aspectos de la evoluci&#243;n natural. A ninguno de
ellos se le ocurri&#243; que esta estrategia podr&#237;a aplicarse de manera
m&#225;s general a los problemas artificiales, pero ese reconocimiento
no tardar&#237;a en llegar: ``La computaci&#243;n evolutiva estaba definitivamente
en el aire en los d&#237;as formativos de la computadora electr&#243;nica''
(Mitchell 1996[<A
 HREF="algen.html#key-47">47</A>], p.2). En 1962, investigadores como G.E.P.
Box, G.J. Friedman, W.W. Bledsoe y H.J. Bremermann hab&#237;an desarrollado
independientemente algoritmos inspirados en la evoluci&#243;n para optimizaci&#243;n
de funciones y aprendizaje autom&#225;tico, pero sus trabajos generaron
poca reacci&#243;n. En 1965 surgi&#243; un desarrollo m&#225;s exitoso, cuando Ingo
Rechenberg, entonces de la Universidad T&#233;cnica de Berl&#237;n, introdujo
una t&#233;cnica que llam&#243; estrategia evolutiva, aunque se parec&#237;a m&#225;s
a los trepacolinas que a los algoritmos gen&#233;ticos. En esta t&#233;cnica
no hab&#237;a poblaci&#243;n ni cruzamiento; un padre mutaba para producir un
descendiente, y se conservaba el mejor de los dos, convirti&#233;ndose
en el padre de la siguiente ronda de mutaci&#243;n (Haupt y Haupt 1998[<A
 HREF="algen.html#key-34">34</A>],
p.146). Versiones posteriores introdujeron la idea de poblaci&#243;n. Las
estrategias evolutivas todav&#237;a se emplean hoy en d&#237;a por ingenieros
y cient&#237;ficos, sobre todo en Alemania.

<P>
El siguiente desarrollo importante en el campo vino en 1966, cuando
L.J. Fogel, A.J. Owens y M.J. Walsh introdujeron en Am&#233;rica una t&#233;cnica
que llamaron programaci&#243;n evolutiva. En este m&#233;todo, las soluciones
candidatas para los problemas se representaban como m&#225;quinas de estado
finito sencillas; al igual que en la estrategia evolutiva de Rechenberg,
su algoritmo funcionaba mutando aleatoriamente una de estas m&#225;quinas
simuladas y conservando la mejor de las dos (Mitchell 1996[<A
 HREF="algen.html#key-47">47</A>],
p.2; Goldberg 1989[<A
 HREF="algen.html#key-29">29</A>], p.105). Tambi&#233;n al igual que las
estrategias evolutivas, hoy en d&#237;a existe una formulaci&#243;n m&#225;s amplia
de la t&#233;cnica de programaci&#243;n evolutiva que todav&#237;a es un &#225;rea de
investigaci&#243;n en curso. Sin embargo, lo que todav&#237;a faltaba en estas
dos metodolog&#237;as era el reconocimiento de la importancia del cruzamiento.

<P>
En una fecha tan temprana como 1962, el trabajo de John Holland sobre
sistemas adaptativos estableci&#243; las bases para desarrollos posteriores;
y lo que es m&#225;s importante, Holland fue tambi&#233;n el primero en proponer
expl&#237;citamente el cruzamiento y otros operadores de recombinaci&#243;n.
Sin embargo, el trabajo fundamental en el campo de los algoritmos
gen&#233;ticos apareci&#243; en 1975, con la publicaci&#243;n del libro ``Adaptaci&#243;n
en Sistemas Naturales y Artificiales''. Basado en investigaciones
y papers anteriores del propio Holland y de colegas de la Universidad
de Michigan, este libro fue el primero en presentar sistem&#225;tica y
rigurosamente el concepto de sistemas digitales adaptativos utilizando
la mutaci&#243;n, la selecci&#243;n y el cruzamiento, simulando el proceso de
la evoluci&#243;n biol&#243;gica como estrategia para resolver problemas. El
libro tambi&#233;n intent&#243; colocar los algoritmos gen&#233;ticos sobre una base
te&#243;rica firme introduciendo el concepto de esquema (Mitchell 1996[<A
 HREF="algen.html#key-47">47</A>],
p.3; Haupt y Haupt 1998[<A
 HREF="algen.html#key-34">34</A>], p.147). Ese mismo a&#241;o, la importante
tesis de Kenneth De Jong estableci&#243; el potencial de los AGs demostrando
que pod&#237;an desenvolverse bien en una gran variedad de funciones de
prueba, incluyendo paisajes de b&#250;squeda ruidosos, discontinuos y multimodales
(Goldberg 1989[<A
 HREF="algen.html#key-29">29</A>], p.107).

<P>
Estos trabajos fundacionales establecieron un inter&#233;s m&#225;s generalizado
en la computaci&#243;n evolutiva. Entre principios y mediados de los 80,
los algoritmos gen&#233;ticos se estaban aplicando en una amplia variedad
de &#225;reas, desde problemas matem&#225;ticos abstractos como el ``problema
de la mochila'' (bin-packing) y la coloraci&#243;n de grafos hasta asuntos
tangibles de ingenier&#237;a como el control de flujo en una l&#237;nea de ensamble,
reconocimiento y clasificaci&#243;n de patrones y optimizaci&#243;n estructural
(Goldberg 1989[<A
 HREF="algen.html#key-29">29</A>], p.128).

<P>
Al principio, estas aplicaciones eran principalmente te&#243;ricas. Sin
embargo, al seguir proliferando la investigaci&#243;n, los algoritmos gen&#233;ticos
migraron hacia el sector comercial, al cobrar importancia con el crecimiento
exponencial de la potencia de computaci&#243;n y el desarrollo de Internet.
Hoy en d&#237;a, la computaci&#243;n evolutiva es un campo floreciente, y los
algoritmos gen&#233;ticos est&#225;n ``resolviendo problemas de inter&#233;s cotidiano''
(Haupt y Haupt 1998[<A
 HREF="algen.html#key-34">34</A>], p.147) en &#225;reas de estudio tan
diversas como la predicci&#243;n en la bolsa y la planificaci&#243;n de la cartera
de valores, ingenier&#237;a aeroespacial, dise&#241;o de microchips, bioqu&#237;mica
y biolog&#237;a molecular, y dise&#241;o de horarios en aeropuertos y l&#237;neas
de montaje. La potencia de la evoluci&#243;n ha tocado virtualmente cualquier
campo que uno pueda nombrar, modelando invisiblemente el mundo que
nos rodea de incontables maneras, y siguen descubri&#233;ndose nuevos usos
mientras la investigaci&#243;n sigue su curso. Y en el coraz&#243;n de todo
esto se halla nada m&#225;s que la simple y poderosa idea de Charles Darwin:
que el azar en la variaci&#243;n, junto con la ley de la selecci&#243;n, es
una t&#233;cnica de resoluci&#243;n de problemas de inmenso poder y de aplicaci&#243;n
casi ilimitada.

<P>

<H1><A NAME="SECTION00040000000000000000">
&#191;Cu&#225;les son las ventajas de los AGs?</A>
</H1>

<P>

<UL>
<LI>El primer y m&#225;s importante punto es que los algoritmos gen&#233;ticos son
intr&#237;nsecamente paralelos. La mayor&#237;a de los otros algoritmos son
en serie y s&#243;lo pueden explorar el espacio de soluciones hacia una
soluci&#243;n en una direcci&#243;n al mismo tiempo, y si la soluci&#243;n que descubren
resulta sub&#243;ptima, no se puede hacer otra cosa que abandonar todo
el trabajo hecho y empezar de nuevo. Sin embargo, ya que los AGs tienen
descendencia m&#250;ltiple, pueden explorar el espacio de soluciones en
m&#250;ltiples direcciones a la vez. Si un camino resulta ser un callej&#243;n
sin salida, pueden eliminarlo f&#225;cilmente y continuar el tabajo en
avenidas m&#225;s prometedoras, d&#225;ndoles una mayor probabilidad en cada
ejecuci&#243;n de encontrar la soluci&#243;n.
<BR>
<BR>Sin embargo, la ventaja del paralelismo va m&#225;s all&#225; de esto. Considere
lo siguiente: todas las cadenas binarias (cadenas de ceros y unos)
de 8 d&#237;gitos forman un espacio de b&#250;squeda, que puede representarse
como ******** (donde * significa ``o 0 o 1''). La
cadena 01101010 es un miembro de este espacio. Sin embargo, tambi&#233;n
es un miembro del espacio 0*******, del espacio 01******,
del espacio 0******0, del espacio 0*1*1*1*, del
espacio 10*01**0, etc&#233;tera. Evaluando la aptitud de esta cadena
particular, un algoritmo gen&#233;tico estar&#237;a sondeando cada uno de los
espacios a los que pertenece. Tras muchas evaluaciones, ir&#237;a obteniendo
un valor cada vez m&#225;s preciso de la aptitud media de cada uno de estos
espacios, cada uno de los cuales contiene muchos miembros. Por tanto,
un AG que eval&#250;e expl&#237;citamente un n&#250;mero peque&#241;o de individuos est&#225;
evaluando impl&#237;citamente un grupo de individuos mucho m&#225;s grande -de
la misma manera que un encuestador que le hace preguntas a un cierto
miembro de un grupo &#233;tnico, religioso o social espera aprender algo
acerca de las opiniones de todos los miembros de ese grupo, y por
tanto puede predecir con fiabilidad la opini&#243;n nacional sondeando
s&#243;lo un peque&#241;o porcentaje de la poblaci&#243;n. De la misma manera, el
AG puede dirigirse hacia el espacio con los individuos m&#225;s aptos y
encontrar el mejor de ese grupo. En el contexto de los algoritmos
evolutivos, esto se conoce como teorema del esquema, y es la ventaja
principal de los AGs sobre otros m&#233;todos de resoluci&#243;n de problemas
(Holland 1992[<A
 HREF="algen.html#key-36">36</A>], p. 68; Mitchell 1996[<A
 HREF="algen.html#key-47">47</A>], p.
28-29; Goldberg 1989[<A
 HREF="algen.html#key-29">29</A>], p. 20).
</LI>
<LI>Debido al paralelismo que les permite evaluar impl&#237;citamente muchos
esquemas a la vez, los algoritmos gen&#233;ticos funcionan particularmente
bien resolviendo problemas cuyo espacio de soluciones potenciales
es realmente grande -demasiado vasto para hacer una b&#250;squeda exhaustiva
en un tiempo razonable. La mayor&#237;a de los problemas que caen en esta
categor&#237;a se conocen como ``no lineales''. En un problema lineal,
la aptitud de cada componente es independiente, por lo que cualquier
mejora en alguna parte dar&#225; como resultado una mejora en el sistema
completo. No es necesario decir que hay pocos problemas como &#233;ste
en la vida real. La no linealidad es la norma, donde cambiar un componente
puede tener efectos en cadena en todo el sistema, y donde cambios
m&#250;ltiples que, individualmente, son perjudiciales, en combinaci&#243;n
pueden conducir hacia mejoras en la aptitud mucho mayores. La no linealidad
produce una explosi&#243;n combinatoria: el espacio de cadenas binarias
de 1.000 d&#237;gitos puede examinarse exhaustivamente evaluando s&#243;lo 2.000
posibilidades si el problema es lineal, mientras que si no es lineal,
una b&#250;squeda exhaustiva requiere evaluar 21.000 posibilidades -un
n&#250;mero que, escrito, ocupar&#237;a m&#225;s de 300 d&#237;gitos.
<BR>
<BR>Afortunadamente, el paralelismo impl&#237;cito de los AGs les permite superar
incluso este enorme n&#250;mero de posibilidades, y encontrar con &#233;xito
resultados &#243;ptimos o muy buenos en un corto periodo de tiempo, tras
muestrear directamente s&#243;lo regiones peque&#241;as del vasto paisaje adaptativo
(Forrest 1993[<A
 HREF="algen.html#key-24">24</A>], p. 877). Por ejemplo, un algoritmo gen&#233;tico
desarrollado en com&#250;n por ingenieros de General Electric y el Rensselaer
Polytechnic Institute produjo el dise&#241;o de la turbina de un motor
a reacci&#243;n de altas prestaciones que era tres veces mejor que la configuraci&#243;n
dise&#241;ada por humanos, y un 50% mejor que una configuraci&#243;n dise&#241;ada
por un sistema experto que recorri&#243; con &#233;xito un espacio de soluciones
que conten&#237;a m&#225;s de 10.387 posibilidades. Los m&#233;todos convencionales
para dise&#241;ar estas turbinas son una parte fundamental de proyectos
de ingenier&#237;a que pueden durar hasta cinco a&#241;os y costar m&#225;s de 2.000
millones de d&#243;lares; el algoritmo gen&#233;tico descubri&#243; esta soluci&#243;n
en dos d&#237;as, en una estaci&#243;n de trabajo de escritorio t&#237;pica en ingenier&#237;a
(Holland 1992[<A
 HREF="algen.html#key-36">36</A>], p. 72).
</LI>
<LI>Otra ventaja notable de los algoritmos gen&#233;ticos es que se desenvuelven
bien en problemas con un paisaje adaptativo complejo -aqu&#233;llos en
los que la funci&#243;n de aptitud es discontinua, ruidosa, cambia con
el tiempo, o tiene muchos &#243;ptimos locales. La mayor&#237;a de los problemas
pr&#225;cticos tienen un espacio de soluciones enorme, imposible de explorar
exhaustivamente; el reto se convierte entonces en c&#243;mo evitar los
&#243;ptimos locales -soluciones que son mejores que todas las que son
similares a ella, pero que no son mejores que otras soluciones distintas
situadas en alg&#250;n otro lugar del espacio de soluciones. Muchos algoritmos
de b&#250;squeda pueden quedar atrapados en los &#243;ptimos locales: si llegan
a lo alto de una colina del paisaje adaptativo, descubrir&#225;n que no
existen soluciones mejores en las cercan&#237;as y concluir&#225;n que han alcanzado
la mejor de todas, aunque existan picos m&#225;s altos en alg&#250;n otro lugar
del mapa.
<BR>
<BR>Los algoritmos evolutivos, por otro lado, han demostrado su efectividad
al escapar de los &#243;ptimos locales y descubrir el &#243;ptimo global incluso
en paisajes adaptativos muy escabrosos y complejos. (Debe decirse
que, en la realidad, a menudo no hay manera de decir si una cierta
soluci&#243;n a un problema es el &#243;ptimo global o s&#243;lo un &#243;ptimo local
muy alto. Sin embargo, aunque un AG no devuelva siempre una soluci&#243;n
perfecta y demostrable a un problema, casi siempre puede devolver
al menos una muy buena soluci&#243;n). Todos los cuatro componentes principales
de los AGs -paralelismo, selecci&#243;n, mutaci&#243;n y cruzamiento- trabajan
juntos para conseguir esto. Al principio, el AG genera una poblaci&#243;n
inicial diversa, lanzando una ``red'' sobre el paisaje adaptativo.
(Koza 2003[<A
 HREF="algen.html#key-42">42</A>], p. 506) compara esto con un ej&#233;rcito de
paracaidistas cayendo sobre el paisaje del espacio de b&#250;squeda de
un problema, cada uno de ellos con &#243;rdenes de buscar el pico m&#225;s alto).
Peque&#241;as mutaciones permiten a cada individuo explorar sus proximidades,
mientras que la selecci&#243;n enfoca el progreso, guiando a la descendencia
del algoritmo cuesta arriba hacia zonas m&#225;s prometedoras del espacio
de soluciones (Holland 1992[<A
 HREF="algen.html#key-36">36</A>], p. 68).
<BR>
<BR>Sin embargo, el cruzamiento es el elemento clave que distingue a los
algoritmos gen&#233;ticos de los otros m&#233;todos como los trepacolinas y
el recocido simulado. Sin el cruzamiento, cada soluci&#243;n individual
va por su cuenta, explorando el espacio de b&#250;squeda en sus inmediaciones
sin referencia de lo que el resto de individuos puedan haber descubierto.
Sin embargo, con el cruzamiento en juego, hay una transferencia de
informaci&#243;n entre los candidatos pr&#243;speros -los individuos pueden
beneficiarse de lo que otros han aprendido, y los esquemas pueden
mezclarse y combinarse, con el potencial de producir una descendencia
que tenga las virtudes de sus dos padres y ninguna de sus debilidades.
Este punto est&#225; ilustrado en Koza et al. 1999[<A
 HREF="algen.html#key-41">41</A>], p. 486,
donde los autores analizan el problema de sintetizar un filtro de
paso bajo utilizando programaci&#243;n gen&#233;tica. En una generaci&#243;n se seleccionaron
dos circuitos progenitores para llevar a cabo el cruzamiento; un padre
ten&#237;a una buena topolog&#237;a (componentes como inductores y condensadores
colocados en el sitio correcto) pero malos tama&#241;os (valores demasiado
bajos de inductancia y capacidad para los componentes). El otro padre
ten&#237;a mala topolog&#237;a pero buenos tama&#241;os. El resultado de aparearlos
mediante cruzamiento fue una descendencia con la buena topolog&#237;a de
un padre y los buenos tama&#241;os del otro, dando como resultado una mejora
sustancial de la aptitud sobre sus dos padres.
<BR>
<BR>El problema de encontrar el &#243;ptimo global en un espacio con muchos
&#243;ptimos locales tambi&#233;n se conoce como el dilema de la exploraci&#243;n
versus explotaci&#243;n, ``un problema cl&#225;sico de todos los sistemas que
pueden adaptarse y aprender'' (Holland 1992[<A
 HREF="algen.html#key-36">36</A>], p. 69).
Una vez que un algoritmo (o un dise&#241;ador humano) ha encontrado una
estrategia para resolver problemas que parece funcionar satisfactoriamente,
&#191;deber&#237;a centrarse en hacer el mejor uso de esa estrategia, o buscar
otras? Abandonar una estrategia de probada solvencia para buscar otras
nuevas casi garantiza que supondr&#225; una p&#233;rdida y degradaci&#243;n del rendimiento,
al menos a corto plazo. Pero si uno se queda con una estrategia particular
excluyendo a todas las dem&#225;s, corre el riesgo de no descubrir estrategias
mejores que existen pero no se han encontrado. De nuevo, los algoritmos
gen&#233;ticos han demostrado ser muy buenos en dar con este equilibrio
y descubrir buenas soluciones en un tiempo y esfuerzo computacional
razonables.
</LI>
<LI>Otro &#225;rea en el que destacan los algoritmos gen&#233;ticos es su habilidad
para manipular muchos par&#225;metros simult&#225;neamente (Forrest 1993[<A
 HREF="algen.html#key-24">24</A>],
p. 874). Muchos problemas de la vida real no pueden definirse en t&#233;rminos
de un &#250;nico valor que hay que minimizar o maximizar, sino que deben
expresarse en t&#233;rminos de m&#250;ltiples objetivos, a menudo involucrando
contrapartidas: uno s&#243;lo puede mejorar a expensas de otro. Los AGs
son muy buenos resolviendo estos problemas: en particular, su uso
del paralelismo les permite producir m&#250;ltiples soluciones, igualmente
buenas, al mismo problema, donde posiblemente una soluci&#243;n candidata
optimiza un par&#225;metro y otra candidata optimiza uno distinto (Haupt
y Haupt 1998[<A
 HREF="algen.html#key-34">34</A>], p. 17), y luego un supervisor humano puede
seleccionar una de esas candidatas para su utilizaci&#243;n. Si una soluci&#243;n
particular a un problema con m&#250;ltiples objetivos optimiza un par&#225;metro
hasta el punto en el que ese par&#225;metro no puede mejorarse m&#225;s sin
causar una correspondiente p&#233;rdida de calidad en alg&#250;n otro par&#225;metro,
esa soluci&#243;n se llama &#243;ptimo paretiano o no dominada (Coello 2000[<A
 HREF="algen.html#key-18">18</A>],
p. 112).
</LI>
<LI>Finalmente, una de las cualidades de los algoritmos gen&#233;ticos que,
a primera vista, puede parecer un desastre, resulta ser una de sus
ventajas: a saber, los AGs no saben nada de los problemas que deben
resolver. En lugar de utilizar informaci&#243;n espec&#237;fica conocida a priori
para guiar cada paso y realizar cambios con un ojo puesto en el mejoramiento,
como hacen los dise&#241;adores humanos, son ``relojeros ciegos'' (Dawkins
1996[<A
 HREF="algen.html#key-20">20</A>]); realizan cambios aleatorios en sus soluciones
candidatas y luego utilizan la funci&#243;n de aptitud para determinar
si esos cambios producen una mejora.
<BR>
<BR>La virtud de esta t&#233;cnica es que permite a los algoritmos gen&#233;ticos
comenzar con una mente abierta, por as&#237; decirlo. Como sus decisiones
est&#225;n basadas en la aleatoriedad, todos los caminos de b&#250;squeda posibles
est&#225;n abiertos te&#243;ricamente a un AG; en contraste, cualquier estrategia
de resoluci&#243;n de problemas que dependa de un conocimiento previo,
debe inevitablemente comenzar descartando muchos caminos a priori,
perdiendo as&#237; cualquier soluci&#243;n novedosa que pueda existir (Koza
et al. 1999[<A
 HREF="algen.html#key-41">41</A>], p. 547). Los AGs, al carecer de ideas preconcebidas
basadas en creencias establecidas sobre ``c&#243;mo deben hacerse las cosas''
o sobre lo que ``de ninguna manera podr&#237;a funcionar'', los AGs no
tienen este problema. De manera similar, cualquier t&#233;cnica que dependa
de conocimiento previo fracasar&#225; cuando no est&#233; disponible tal conocimiento,
pero, de nuevo, los AGs no se ven afectados negativamente por la ignorancia
(Goldberg 1989[<A
 HREF="algen.html#key-29">29</A>], p. 23). Mediante sus componentes de
paralelismo, cruzamiento y mutaci&#243;n, pueden viajar extensamente por
el paisaje adaptativo, explorando regiones que algoritmos producidos
con inteligencia podr&#237;an no haber tenido en cuenta, y revelando potencialmente
soluciones de asombrosa e inesperada creatividad que podr&#237;an no hab&#233;rseles
ocurrido nunca a los dise&#241;adores humanos. Un ejemplo muy gr&#225;fico de
esto es el redescubrimiento, mediante la programaci&#243;n gen&#233;tica, del
concepto de retroalimentaci&#243;n negativa -un principio crucial para
muchos componentes electr&#243;nicos importantes de hoy en d&#237;a, pero un
concepto que, cuando fue descubierto en primera instancia, se le deneg&#243;
una patente de nueve a&#241;os porque el concepto era demasiado contrario
a las creencias establecidas (Koza et al. 2003[<A
 HREF="algen.html#key-42">42</A>], p. 413).
Por supuesto, los algoritmos evolutivos no est&#225;n enterados ni preocupados
de si una soluci&#243;n va en contra de las creencias establecidas -s&#243;lo
de si funciona.
</LI>
</UL>

<P>

<H1><A NAME="SECTION00050000000000000000">
&#191;Cu&#225;les son las limitaciones de los AGs?</A>
</H1>

<P>
Aunque los algoritmos gen&#233;ticos han demostrado su eficiencia y potencia
como estrategia de resoluci&#243;n de problemas, no son la panacea. Los
AGs tienen ciertas limitaciones; sin embargo, se demostrar&#225; que todas
ellas pueden superarse y que ninguna de ellas afecta a la validez
de la evoluci&#243;n biol&#243;gica.

<P>

<UL>
<LI>La primera y m&#225;s importante consideraci&#243;n al crear un algoritmo gen&#233;tico
es definir una representaci&#243;n del problema. El lenguaje utilizado
para especificar soluciones candidatas debe ser robusto; es decir,
debe ser capaz de tolerar cambios aleatorios que no produzcan constantemente
errores fatales o resultados sin sentido.
<BR>
<BR>Hay dos maneras principales para conseguir esto. La primera, utilizada
por la mayor&#237;a de los algoritmos gen&#233;ticos, es definir a los individuos
como listas de n&#250;meros -binarios, enteros o reales- donde cada n&#250;mero
representa alg&#250;n aspecto de la soluci&#243;n candidata. Si los individuos
son cadenas binarias, un 0 o 1 podr&#237;a significar la ausencia o presencia
de una cierta caracter&#237;stica. Si son listas de n&#250;meros, estos n&#250;meros
podr&#237;an representar muchas cosas distintas: los pesos de las conexiones
en una red neuronal, el orden de las ciudades visitadas en un recorrido
dado, la situaci&#243;n espacial de componentes electr&#243;nicos, los valores
con los que se alimenta a un controlador, los &#225;ngulos de torsi&#243;n de
los enlaces p&#233;ptidos de una prote&#237;na, etc&#233;tera. As&#237;, la mutaci&#243;n implica
cambiar estos n&#250;meros, cambiar bits o sumar o restar valores aleatorios.
En este caso, el propio c&#243;digo del programa no cambia; el c&#243;digo es
lo que dirige la simulaci&#243;n y hace un seguimiento de los individuos,
evaluando sus aptitudes y quiz&#225; asegurando que s&#243;lo se producen valores
realistas y posibles para el problema dado.
<BR>
<BR>En otro m&#233;todo, la programaci&#243;n gen&#233;tica, el propio c&#243;digo del programa
<SPAN  CLASS="textit">s&#237;</SPAN> cambia. Como ya se dijo en la secci&#243;n ``M&#233;todos de representaci&#243;n'',
la PG representa a los individuos como &#225;rboles de c&#243;digo ejecutables
que pueden mutar cambiando o intercambiando sub&#225;rboles. Ambos m&#233;etodos
producen representaciones robustas ante la mutaci&#243;n, y pueden representar
muchos tipos diferentes de problemas y, como se dice en la secci&#243;n
``Algunos ejemplos espec&#237;ficos'', ambas han tenido un &#233;xito considerable.
<BR>
<BR>El problema de representar a las soluciones candidatas de manera robusta
no surge en la naturaleza, porque el m&#233;todo de representaci&#243;n utilizado
por la evoluci&#243;n, a saber, el c&#243;digo gen&#233;tico, es inherentemente robusto:
con muy pocas excepciones, como una cadena de codones de parada, no
existe una secuencia de bases de ADN que no pueda traducirse en una
prote&#237;na. Por lo tanto, virtualmente, cualquier cambio en los genes
de un individuo siempre producir&#225; un resultado inteligible, y por
tanto las mutaciones en la evoluci&#243;n tienen mayor probabilidad de
producir una mejora. Esto entra en contraste con los lenguajes creados
por el hombre como el ingl&#233;s, donde el n&#250;mero de palabras con significado
es peque&#241;o comparado con el n&#250;mero total de formas en las que se pueden
combinar las letras del alfabeto, y por tanto, es probable que un
cambio aleatorio en una frase en ingl&#233;s produzca un sinsentido.
</LI>
<LI>El problema de c&#243;mo escribir la funci&#243;n de aptitud debe considerarse
cuidadosamente para que se pueda alcanzar una mayor aptitud y verdaderamente
signifique una soluci&#243;n mejor para el problema dado. Si se elige mal
una funci&#243;n de aptitud o se define de manera inexacta, puede que el
algoritmo gen&#233;tico sea incapaz de encontrar una soluci&#243;n al problema,
o puede acabar resolviendo el problema equivocado. (Esta &#250;ltima situaci&#243;n
se describe a veces como la tendencia del AG a ``enga&#241;ar'', aunque
en realidad lo que est&#225; pasando es que el AG est&#225; haciendo lo que
se le pidi&#243; hacer, no lo que sus creadores pretend&#237;an que hiciera).
Se puede encontrar un ejemplo de esto en Graham-Rowe 2002[<A
 HREF="algen.html#key-30">30</A>],
donde unos investigadores utilizaron un algoritmo evolutivo en conjunci&#243;n
con una serie de chips reprogramables, haciendo que la funci&#243;n de
aptitud recompensara al circuito en evoluci&#243;n por dar como salida
una se&#241;al oscilatoria. Al final del experimento, se produc&#237;a efectivamente
una se&#241;al oscilatoria -pero en lugar de actuar como un osculador,
como pretend&#237;an los investigadores, &#161;descubrieron que el circuito
se hab&#237;a convertido en un receptor de radio que estaba recibiendo
y retransmitiendo una se&#241;al oscilatoria de un componente electr&#243;nico
cercano!
<BR>
<BR>Sin embargo, esto no es un problema en la naturaleza. En el laboratorio
de la evoluci&#243;n biol&#243;gica, s&#243;lo hay una funci&#243;n de aptitud que es
igual para todos los seres vivos -la carrera por sobrevivir y reproducirse,
sin importar qu&#233; adaptaciones hagan esto posible. Los organismos que
se reproducen con m&#225;s abundancia que sus competidores est&#225;n m&#225;s adaptados;
los que fracasan en reproducirse no est&#225;n adaptados.
</LI>
<LI>Adem&#225;s de elegir bien la funci&#243;n de aptitud, tambi&#233;n deben elegirse
cuidadosamente los otros par&#225;metros de un AG -el tama&#241;o de la poblaci&#243;n,
el ritmo de mutaci&#243;n y cruzamiento, el tipo y fuerza de la selecci&#243;n.
Si el tama&#241;o de la poblaci&#243;n es demasiado peque&#241;o, puede que el algoritmo
gen&#233;tico no explore suficientemente el espacio de soluciones para
encontrar buenas soluciones consistentemente. Si el ritmo de cambio
gen&#233;tico es demasiado alto o el sistema de selecci&#243;n se escoge inadecuadamente,
puede alterarse el desarrollo de esquemas beneficiosos y la poblaci&#243;n
puede entrar en cat&#225;strofe de errores, al cambiar demasiado r&#225;pido
para que la selecci&#243;n llegue a producir convergencia.
<BR>
<BR>Los seres vivos tambi&#233;n se enfrentan a dificultades similares, y la
evoluci&#243;n se ha encargado de ellas. Es cierto que si el tama&#241;o de
una poblaci&#243;n cae hacia un valor muy bajo, los ritmos de mutaci&#243;n
son muy altos o la presi&#243;n selectiva es demasiado fuerte (una situaci&#243;n
as&#237; podr&#237;a ser resultado de un cambio ambiental dr&#225;stico), entonces
la especie puede extinguirse. La soluci&#243;n ha sido ``la evoluci&#243;n de
la evolutividad'' -las adaptaciones que alteran la habilidad de una
especie para adaptarse. Un ejemplo. La mayor&#237;a de los seres vivos
han evolucionado una elaborada maquinaria celular que comprueba y
corrigue errores durante el proceso de replicaci&#243;n del ADN, manteniendo
su ritmo de mutaci&#243;n a unos niveles aceptablemente bajos; a la inversa,
en tiempos de fuerte presi&#243;n ambiental, algunas especies de bacterias
entran en un estado de hipermutaci&#243;n en el que el ritmo de errores
en la replicaci&#243;n del ADN aumenta bruscamente, aumentando la probabilidad
de que se descubrir&#225; una mutaci&#243;n compensatoria. Por supuesto, no
pueden eludirse todas las cat&#225;strofes, pero la enorme diversidad y
las adaptaciones altamente complejas de los seres vivos actuales muestran
que, en general, la evoluci&#243;n es una estrategia exitosa. Igualmente,
las aplicaciones diversas y los impresionantes resultados de los algoritmos
gen&#233;ticos demuestran que son un campo de estudio poderoso y que merece
la pena.
</LI>
<LI>Un problema con el que los algoritmos gen&#233;ticos tienen dificultades
son los problemas con las funciones de aptitud ``enga&#241;osas'' (Mitchell
1996[<A
 HREF="algen.html#key-47">47</A>], p. 125), en las que la situaci&#243;n de los puntos
mejorados ofrecen informaci&#243;n enga&#241;osa sobre d&#243;nde se encuentra probablemente
el &#243;ptimo global. Por ejemplo: imagine un problema en el que el espacio
de b&#250;squeda est&#233; compuesto por todas las cadenas binarias de ocho
caracteres, y en el que la aptitud de cada individuo sea directamente
proporcional al n&#250;mero de unos en &#233;l -es decir, 00000001 ser&#237;a menos
apto que 00000011, que ser&#237;a menos apto que 00000111, etc&#233;tera -,
con dos excepciones: la cadena 11111111 resulta tener una aptitud
muy baja, y la cadena 00000000 resulta tener una aptitud muy alta.
En este problema, un AG (al igual que la mayor&#237;a de los algoritmos)
no tendr&#237;a m&#225;s probabilidad de encontrar un &#243;ptimo global que una
b&#250;squeda aleatoria.
<BR>
<BR>La soluci&#243;n a este problema es la misma para los algoritmos gen&#233;ticos
y la evoluci&#243;n biol&#243;gica: la evoluci&#243;n no es un proceso que deba encontrar
siempre el &#243;ptimo global. Puede funcionar casi igual de bien alcanzando
la cima de un &#243;ptimo local alto y, para la mayor&#237;a de las situaciones,
eso ser&#225; suficiente, incluso aunque el &#243;ptimo global no pueda alcanzarse
f&#225;cilmente desde ese punto. La evoluci&#243;n es como un ``satisfactor''
-un algoritmo que entrega una soluci&#243;n ``suficientemente buena'',
aunque no necesariamente la mejor soluci&#243;n posible, dada una cantidad
razonable de tiempo y esfuerzo invertidos en la b&#250;squeda. La
``<a href="http://www.talkorigins.org/faqs/jury-rigged.html">FAQ
de la evidencia de dise&#241;o improvisado en la naturaleza</a>'' proporciona
ejemplos de la naturaleza con estos resultados. (Tambi&#233;n hay que tener
en cuenta que pocos o ning&#250;n problema real es tan enga&#241;oso como el
ejemplo algo forzado dado arriba. Normalmente, la situaci&#243;n de las
mejoras locales proporciona alguna informaci&#243;n sobre la situaci&#243;n
del &#243;ptimo global).
</LI>
<LI>Un problema muy conocido que puede surgir con un AG se conoce como
convergencia prematura. Si un individuo que es m&#225;s apto que la mayor&#237;a
de sus competidores emerge muy pronto en el curso de la ejecuci&#243;n,
se puede reproducir tan abundantemente que merme la diversidad de
la poblaci&#243;n demasiado pronto, provocando que el algoritmo converja
hacia el &#243;ptimo local que representa ese individuo, en lugar de rastrear
el paisaje adaptativo lo bastante a fondo para encontrar el &#243;ptimo
global (Forrest 1993[<A
 HREF="algen.html#key-24">24</A>], p. 876; Mitchell 1996[<A
 HREF="algen.html#key-47">47</A>],
p. 167). Esto es un problema especialmente com&#250;n en las poblaciones
peque&#241;as, donde incluso una variaci&#243;n aleatoria en el ritmo de reproducci&#243;n
puede provocar que un genotipo se haga dominante sobre los otros.
<BR>
<BR>Los m&#233;todos m&#225;s comunes implementados por los investigadores en AGs
para solucionar este problema implican controlar la fuerza selectiva,
para no proporcionar tanta ventaja a los individuos excesivamente
aptos. La selecci&#243;n escalada, por rango y por torneo, discutidas anteriormente,
son tres de los m&#233;todos principales para conseguir esto; algunos m&#233;todos
de selecci&#243;n escalada son el escalado sigma, en el que la reproducci&#243;n
se basa en una comparaci&#243;n estad&#237;stica de la aptitud media de la poblaci&#243;n,
y la selecci&#243;n de Boltzmann, en la que la fuerza selectiva aumenta
durante la ejecuci&#243;n de manera similar a la variable ``temperatura''
en el recocido simulado (Mitchell 1996[<A
 HREF="algen.html#key-47">47</A>], p. 168).
<BR>
<BR>La convergencia prematura ocurre en la naturaleza (los bi&#243;logos la
llaman deriva gen&#233;tica). Esto no debe sorprender; como ya se dijo
arriba, la evoluci&#243;n, como estrategia de resoluci&#243;n de problemas,
no est&#225; obligada a encontrar la mejor soluci&#243;n, s&#243;lo una que sea lo
bastante buena. Sin embargo, en la naturaleza, la convergencia prematura
es menos com&#250;n, ya que la mayor&#237;a de las mutaciones beneficiosas en
los seres vivos s&#243;lo producen mejoras en la aptitud peque&#241;as e incrementales;
son raras las mutaciones que producen una ganancia de aptitud tan
grande que otorgue a sus poseedores una dr&#225;stica ventaja reproductiva.
</LI>
<LI>Finalmente, varios investigadores (Holland 1992[<A
 HREF="algen.html#key-36">36</A>], p.
72; Forrest 1993[<A
 HREF="algen.html#key-24">24</A>], p. 875; Haupt y Haupt 1998[<A
 HREF="algen.html#key-34">34</A>],
p. 18) aconsejan no utilizar algoritmos gen&#233;ticos en problemas resolubles
de manera anal&#237;tica. No es que los algoritmos gen&#233;ticos no puedan
encontrar soluciones buenas para estos problemas; simplemente es que
los m&#233;todos anal&#237;ticos tradicionales consumen mucho menos tiempo y
potencia computacional que los AGs y, a diferencia de los AGs, a menudo
est&#225; demostrado matem&#225;ticamente que ofrecen la &#250;nica soluci&#243;n exacta.
Por supuesto, como no existe una soluci&#243;n matem&#225;tica perfecta para
ning&#250;n problema de adaptaci&#243;n biol&#243;gica, este problema no aparece
en la naturaleza.
</LI>
</UL>

<P>

<H1><A NAME="SECTION00060000000000000000">
Algunos ejemplos espec&#237;ficos de AG </A>
</H1>

<P>
Mientras el poder de la evoluci&#243;n gana reconocimiento cada vez m&#225;s
generalizado, los algoritmos gen&#233;ticos se utilizan para abordar una
amplia variedad de problemas en un conjunto de campos sumamente diverso,
demostrando claramente su capacidad y su potencial. Esta secci&#243;n analizar&#225;
algunos de los usos m&#225;s notables en los que han tomado parte.

<P>

<H2><A NAME="SECTION00061000000000000000">
Ac&#250;stica</A>
</H2>

<P>
Sato et al. 2002[<A
 HREF="algen.html#key-58">58</A>] utilizaron algoritmos gen&#233;ticos para
dise&#241;ar una sala de conciertos con propiedades ac&#250;sticas &#243;ptimas,
maximizando la calidad del sonido para la audiencia, para el director
y para los m&#250;sicos del escenario. Esta tarea implica la optimizaci&#243;n
simult&#225;nea de m&#250;ltiples variables. Comenzando con una sala con forma
de caja de zapatos, el AG de los autores produjo dos soluciones no
dominadas, ambas descritas como ``con forma de hoja'' (p. 526). Los
autores afirman que estas soluciones tienen proporciones similares
al Grosser Musikvereinsaal de Viena, el cual est&#225; considerado generalmente
como una de las mejores -si no la mejor- salas de conciertos del
mundo, en t&#233;rminos de propiedades ac&#250;sticas.

<P>
Porto, Fogel y Fogel 1995[<A
 HREF="algen.html#key-51">51</A>] utilizaron programaci&#243;n evolutiva
para adiestrar a redes neuronales para distinguir entre reflexiones
sonoras desde distintos tipos de objetos: esferas met&#225;licas hechas
por el hombre, monta&#241;as submarinas, peces y plantas, y ruido aleatorio
de fondo. Tras 500 generaciones, la mejor red neuronal que evolucion&#243;
ten&#237;a una probabilidad de clasificaci&#243;n correcta que iba desde el
94% al 98%, y una probabilidad de clasificaci&#243;n errónea entre un 7,4%
y un 1,5%, que son ``probabilidades razonables de detecci&#243;n y falsa
alarma'' (p. 21). Esta red evolucionada igual&#243; las prestaciones de
otra red desarrollada mediante recocido simulado, y super&#243; consistentemente
a redes entrenadas mediante propagaci&#243;n hacia atr&#225;s, las cuales ``se
atascaban repetidamente en conjuntos de pesos sub&#243;ptimos que no produc&#237;an
resultados satisfactorios'' (p. 21). En contraste, ambos m&#233;todos estoc&#225;sticos
demostraron su capacidad para superar estos &#243;ptimos locales y producir
redes m&#225;s pequeñas, efectivas y robustas; pero los autores sugieren
que el algoritmo evolutivo, a diferencia del recocido simulado, opera
sobre una poblaci&#243;n, y por tanto se beneficia de la informaci&#243;n global
sobre el espacio de b&#250;squeda, conduciendo potencialmente hacia un
rendimiento mayor a la larga.

<P>
Tang et al. 1996[<A
 HREF="algen.html#key-62">62</A>] analizan los usos de los algoritmos
gen&#233;ticos en el campo de la ac&#250;stica y el procesamiento de se&#241;ales.
Un &#225;rea de inter&#233;s particular incluye el uso de AGs para dise&#241;ar sistemas
de Control Activo de Ruido (CAR), que eliminan el sonido no deseado
produciendo ondas sonoras que interfieren destructivamente con el
ruido. Esto es un problema de m&#250;ltiples objetivos que requiere el
control y la colocaci&#243;n precisa de m&#250;ltiples altavoces; los AGs se
han utilizado en estos sistemas tanto para dise&#241;ar los controladores
como para encontrar la colocaci&#243;n &#243;ptima de los altavoces, dando como
resultado una ``atenuaci&#243;n efectiva del ruido'' (p. 33) en pruebas
experimentales.

<P>

<H2><A NAME="SECTION00062000000000000000">
Ingenier&#237;a aeroespacial</A>
</H2>

<P>
Obayashi et al. 2000[<A
 HREF="algen.html#key-49">49</A>] utilizaron un algoritmo gen&#233;tico
de m&#250;ltiples objetivos para dise&#241;ar la forma del ala de un avi&#243;n supers&#243;nico.
Hay tres consideraciones principales que determinan la configuraci&#243;n
del ala -minimizar la resistencia aerodin&#225;mica a velocidades de vuelo
supers&#243;nicas, minimizar la resistencia a velocidades subs&#243;nicas y
minimizar la carga aerodin&#225;mica (la fuerza que tiende a doblar el
ala). Estos objetivos son mutuamente exclusivos, y optimizarlos todos
simult&#225;neamente requiere realizar contrapartidas.

<P>
El cromosoma de este problema es una cadena de 66 n&#250;meros reales,
cada uno de los cuales corresponde a un aspecto espec&#237;fico del ala:
su forma, su grosor, su torsi&#243;n, etc&#233;tera. Se simul&#243; una evoluci&#243;n
con selecci&#243;n elitista durante 70 generaciones, con un tama&#241;o de poblaci&#243;n
de 64 individuos. Al final de este proceso hab&#237;a varios individuos
paretianos, cada uno representando una soluci&#243;n no dominada del problema.
El art&#237;culo comenta que estos individuos ganadores ten&#237;an caracter&#237;sticas
``f&#237;sicamente razonables'', se&#241;alando la validez de la t&#233;cnica de
optimizaci&#243;n (p. 186). Para evaluar mejor la calidad de las soluciones,
las seis mejores fueron comparadas con un dise&#241;o de ala supers&#243;nica
producido por el Equipo de Dise&#241;o SST del Laboratorio Aeroespacial
Nacional de Jap&#243;n. Las seis fueron competitivas, con valores de resistencia
y carga aproximadamente iguales o menores a los del ala dise&#241;ada por
humanos; en particular, una de las soluciones evolucionadas super&#243;
al dise&#241;o del LAN en los tres objetivos. Los autores se&#241;alan que las
soluciones del AG son similares a un dise&#241;o llamado ``ala flecha'',
sugerido por primera vez a finales de los a&#241;os 50, pero que finalmente
fue abandonado en favor del dise&#241;o m&#225;s convencional con forma de delta.

<P>
En un art&#237;culo posterior (Sasaki et al. 2001[<A
 HREF="algen.html#key-57">57</A>]), los autores
repitieron el experimento a&#241;adiendo un cuarto objetivo, a saber, minimizar
el momento de torsi&#243;n (un conocido problema en los dise&#241;os de alas
flecha en el vuelo supers&#243;nico). Tambi&#233;n se a&#241;adieron puntos de control
adicionales para el grosor al conjunto de variables de dise&#241;o. Tras
75 generaciones de evoluci&#243;n, se compararon dos de las mejores soluciones
paretianas con el dise&#241;o de ala que el Laboratorio Aeroespacial Nacional
japon&#233;s realiz&#243; para el avi&#243;n supers&#243;nico experimental NEXST-1. Se
descubri&#243; que ambos dise&#241;os (adem&#225;s de un dise&#241;o &#243;ptimo de la simulaci&#243;n
anterior, explicada arriba) eran f&#237;sicamente razonables y superiores
al dise&#241;o del LAN en los cuatro objetivos.

<P>
Williams, Crossley y Lang 2001[<A
 HREF="algen.html#key-64">64</A>] aplicaron algoritmos
gen&#233;ticos a la tarea de situar &#243;rbitas de sat&#233;lites para minimizar
los apagones de cobertura. Mientras la tecnolog&#237;a de telecomunicaciones
sigue progresando, los humanos somos cada vez m&#225;s dependientes de
las funciones vitales que realizan los sat&#233;lites en &#243;rbita alrededor
de la Tierra, y uno de los problemas con los que se enfrentan los
ingenieros es el dise&#241;o de las trayectorias orbitales. Los sat&#233;lites
que se encuentran en una &#243;rbita terrestre alta, a unos 35.000 kil&#243;metros
de altitud, pueden ver amplias secciones del planeta al mismo tiempo
y estar en contacto con las estaciones terrestres, pero son mucho
m&#225;s caros de lanzar y m&#225;s vulnerables a las radiaciones c&#243;smicas.
Es m&#225;s econ&#243;mico colocar sat&#233;lites en &#243;rbitas bajas, en algunos casos
a s&#243;lo unos pocos cientos de kil&#243;metros; pero, a causa de la curvatura
de la Tierra, es inevitable que estos sat&#233;lites pierdan durante un
tiempo la l&#237;nea de visi&#243;n con los receptores terrestres, y por lo
tanto se vuelven in&#250;tiles. Incluso las constelaciones de varios sat&#233;lites
tienen apagones ineludibles y p&#233;rdidas de cobertura por esta raz&#243;n.
El reto consiste en colocar las &#243;rbitas de los sat&#233;lites para minimizar
este tiempo muerto. Esto es un problema multi-objetivo que implica
la minimizaci&#243;n de el tiempo medio de apag&#243;n para todas las localizaciones
y el tiempo m&#225;ximo de apag&#243;n para cada una de las localizaciones;
en la pr&#225;ctica, estos objetivos resultan ser mutuamente exclusivos.

<P>
Cuando se utiliz&#243; el AG en este problema, los resultados que evolucionaron
para constelaciones de tres, cuatro y cinco sat&#233;lites eran extra&#241;os,
configuraciones orbitales muy asim&#233;tricas, con los sat&#233;lites colocados
alternando huecos grandes y peque&#241;os, en lugar de huecos de igual
tama&#241;o como habr&#237;an hecho las t&#233;cnicas convencionales. Sin embargo,
esta soluci&#243;n redujo significativamente los tiempos medio y m&#225;ximo
de apag&#243;n, en algunos casos hasta en 90 minutos. En un art&#237;culo period&#237;stico,
el Dr. William Crossley se&#241;al&#243; que ``ingenieros con a&#241;os de experiencia
aeroespacial quedaorn sorprendidos con el rendimiento ofrecido por
el dise&#241;o no convencional''.

<P>
Keane y Brown 1996[<A
 HREF="algen.html#key-43">43</A>] utilizadon un AG para producir un
nuevo dise&#241;o para un brazo o jirafa para transportar carga que pudiese
montarse en &#243;rbita y utilizarse con sat&#233;lites, estaciones espaciales
y otros proyectos de construcci&#243;n aeroespacial. El resultado, una
estructura retorcida con aspecto org&#225;nico que se ha comparado con
un f&#233;mur humano, no utiliza m&#225;s material que el dise&#241;o de brazo est&#225;ndar,
pero es ligera, fuerte y muy superior a la hora de amortiguar las
vibraciones perjudiciales, como confirmaron las pruebas reales del
producto final. Y sin embargo ``Ninguna inteligencia produjo los dise&#241;os.
Simplemente evolucionaron'' (Petit 1998[<A
 HREF="algen.html#key-43">43</A>]). Los autores
del art&#237;culo comentan adem&#225;s que su AG s&#243;lo se ejecut&#243; durante 10
generaciones, debido a la naturaleza computacionalmente costosa de
la simulaci&#243;n, y la poblaci&#243;n no se hab&#237;a estancado todav&#237;a. Haber
proseguido la ejecuci&#243;n durante m&#225;s generaciones habr&#237;a producido
indudablemente mayores mejoras de rendimiento.

<P>

<DIV ALIGN="CENTER"><A NAME="533"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
Un brazo tridimensional optimizado
gen&#233;ticamente, con una respuesta mejorada a la frecuencia (adaptado
de http://www.soton.ac.uk/~ajk/truss/welcome.html).</CAPTION>
<TR><TD><IMG
  WIDTH="355" HEIGHT="233" ALIGN="BOTTOM" BORDER="0"
 SRC="./3dbeam.jpg"
 ALT="Image 3dbeam">

<P></TD></TR>
</TABLE>
</DIV>

<P>
Finalmente, como informa Gibbs 1996[<A
 HREF="algen.html#key-25">25</A>], Lockheed Martin
ha utilizado un algoritmo gen&#233;tico para producir mediante evoluci&#243;n
una serie de maniobras para mover una nave espacial de una orientaci&#243;n
a otra, dentro del 2% del tiempo m&#237;nimo te&#243;rico para tales maniobras.
La soluci&#243;n evolucionada era un 10% m&#225;s r&#225;pida que una soluci&#243;n producida
manualmente por un experto para el mismo problema.

<P>

<H2><A NAME="SECTION00063000000000000000">
Astronom&#237;a y astrof&#237;sica</A>
</H2>

<P>
Charbonneau 1995[<A
 HREF="algen.html#key-12">12</A>] sugiere la utilidad de los AGs para
problemas de astrof&#237;sica, aplic&#225;ndolos a tres problemas de ejemplo:
obtener la curva de rotaci&#243;n de una galaxia bas&#225;ndose en las velocidades
rotacionales observadas de sus componentes, determinar el periodo
de pulsaci&#243;n de una estrella variable bas&#225;ndose en series de datos
temporales, y sacar los valores de los par&#225;metros cr&#237;ticos de un modelo
magnetohidrodin&#225;mico del viento solar. Son tres dif&#237;ciles problemas
no lineales y multidimensionales.

<P>
El algoritmo gen&#233;tico de Charbonneau, PIKAIA, utiliza selecci&#243;n generacional
y proporcional a la aptitud, junto con elitismo, para asegurar que
el mejor individuo se copia una vez hacia la siguiente generaci&#243;n
sin ninguna modificaci&#243;n. PIKAIA tiene un ritmo de cruzamiento de
0,65 y un ritmo de mutaci&#243;n variable que se pone a 0,003 inicialmente
y luego aumenta gradualmente, mientras la poblaci&#243;n se aproxima a
la convergencia, para mantener la variabilidad en el acervo gen&#233;tico.

<P>
En el problema de la curva de rotaci&#243;n gal&#225;ctica, el AG produjo dos
curvas, y ambas estaban bien ajustadas a los datos (un resultado com&#250;n
en este tipo de problema, en el que hay poco contraste entre cimas
cercanas); observaciones posteriores pueden distinguir cu&#225;l es la
preferible. En el problema de la serie temporal, el AG fue impresionantemente
exitoso, generando un ajuste de los datos de gran calidad, aunque
otros problemas m&#225;s dif&#237;ciles no se ajustaron tan bien (aunque, como
se&#241;ala Charbonneau, estos problemas son igualmente dif&#237;ciles de resolver
con t&#233;cnicas convencionales). El art&#237;culo sugiere que un AG h&#237;brido
que emplee tanto evoluci&#243;n artificial como t&#233;cnicas anal&#237;ticas est&#225;ndar,
podr&#237;a funcionar mejor. Finalmente, en el problema de obtener los
seis par&#225;metros cr&#237;ticos del viento solar, el AG determin&#243; con &#233;xito
el valor de tres con una precisi&#243;n de menos del 0,1% y los otros
tres con precisiones entre el 1 y el 10%. (Aunque siempre ser&#237;an
preferibles unos errores experimentales menores para estos tres par&#225;metros,
Charbonneau se&#241;ala que no existe ning&#250;n otro m&#233;todo eficiente y robusto
para resolver experimentalmente un problema no lineal 6-dimensional
de este tipo; un m&#233;todo de gradiente conjugado funciona ``siempre
que se pueda proporcionar un valor inicial muy acertado'' (p. 323).
En contraste, los AGs no requieren un conocimiento del dominio tan
bien afinado).

<P>
Bas&#225;ndose en los resultados obtenidos hasta ahora, Charbonneau sugiere
que los AGs pueden y deben encontrar uso en otros problemas dif&#237;ciles
de astrof&#237;sica, en particular, problemas inversos como las im&#225;genes
por Doppler y las inversiones helios&#237;smicas. Para terminar, Charbonneau
sostiene que los AGs son un ``contendiente poderoso y prometedor''
(p. 324) en este campo, del que se puede esperar que complemente (no
sustituya) a las t&#233;cnicas tradicionales de optimizaci&#243;n, y concluye
que ``el punto decisivo, si es que tiene que haber alguno, es que
los algoritmos gen&#233;ticos funcionan, y a menudo colosalmente bien''
(p. 325).

<P>

<H2><A NAME="SECTION00064000000000000000">
Qu&#237;mica</A>
</H2>

<P>
Un pulso l&#225;ser ultracorto de alta energ&#237;a puede romper mol&#233;culas complejas
en mol&#233;culas m&#225;s sencillas, un proceso con aplicaciones importantes
en la qu&#237;mica org&#225;nica y la microelectr&#243;nica. Los productos espec&#237;ficos
de una reacci&#243;n as&#237; pueden controlarse modulando la fase del pulso
l&#225;ser. Sin embargo, para mol&#233;culas grandes, obtener la forma del pulso
deseado de manera anal&#237;tica es demasiado dif&#237;cil: los c&#225;lculos son
demasiado complejos y las caracter&#237;sticas relevantes (las superficies
de energ&#237;a potencial de las mol&#233;culas) no se conocen con suficiente
precisi&#243;n.

<P>
Assion et al. 1998[<A
 HREF="algen.html#key-6">6</A>] resolvieron este problema utilizando
un algoritmo evolutivo para dise&#241;ar la forma del pulso. En lugar de
introducir informaci&#243;n compleja, espec&#237;fica del problema, sobre las
caracter&#237;sticas cu&#225;nticas de las mol&#233;culas iniciales, para dise&#241;ar
el pulso conforme a las especificaciones, el AE dispara un pulso,
mide las proporciones de las mol&#233;culas producto resultantes, muta
aleatoriamente las caracter&#237;sticas del rayo con la esperanza de conseguir
que estas proporciones se acerquen a la salida deseada, y el proceso
se repite. (En lugar de afinar directamente las caracter&#237;sticas del
rayo l&#225;ser, el AG de los autores representa a los individuos como
un conjunto de 128 n&#250;meros, en el que cada n&#250;mero es un valor de voltaje
que controla el &#237;ndice de refracci&#243;n de uno de los pixeles del modulador
l&#225;ser. De nuevo, no se necesita un conocimiento espec&#237;fico del problema
sobre las propiedades del l&#225;ser o de los productos de la reacci&#243;n).
Los autores afirman que su algoritmo, cuando se aplica a dos sustancias
de muestra, ``encuentra autom&#225;ticamente la mejor configuraci&#243;n...
no importa lo complicada que sea la respuesta molecular'' (p. 921),
demostrando un ``control coherente automatizado de los productos que
son qu&#237;micamente diferentes uno del otro y de la mol&#233;cula padre''
(p. 921).

<P>
A principios y mediados de los 90, la amplia adopci&#243;n de una novedosa
t&#233;cnica de dise&#241;o de f&#225;rmacos, llamada qu&#237;mica combinatoria, revolucion&#243;
la industria farmac&#233;utica. Con este m&#233;todo, en lugar de la s&#237;ntesis
precisa y meticulosa de un s&#243;lo compuesto de una vez, los bioqu&#237;micos
mezclan deliberadamente una gran variedad de reactivos para producir
una variedad a&#250;n mayor de productos -cientos, miles o millones de
compuestos diferentes en cada remesa- que luego pueden aislarse r&#225;pidamente
para su actividad bioqu&#237;mica. Hay dos formas de dise&#241;ar las bibliotecas
de reactivos en esta t&#233;cnica: dise&#241;o basado en los reactivos, que
elige grupos optimizados de reactivos sin considerar qu&#233; productos
saldr&#225;n como resultado, y dise&#241;o basado en los productos, que selecciona
los reactivos que producir&#225;n con mayor probabilidad los productos
con las propiedades deseadas. El dise&#241;o basado en los productos es
m&#225;s dif&#237;cil y complejo, pero se ha demostrado que genera bibliotecas
combinatorias mejores y m&#225;s diversas, y tiene m&#225;s probabilidades de
ofrecer un resultado &#250;til.

<P>
En un art&#237;culo patrocinado por el departamento de investigaci&#243;n y
desarrollo de GlaxoSmithKline, Gillet 2002[<A
 HREF="algen.html#key-26">26</A>] describe
el uso de un algoritmo gen&#233;tico multiobjetivo para el dise&#241;o basado
en los productos de bibliotecas combinatorias. Al elegir los componentes
que van en una biblioteca particular, deben considerarse caracter&#237;sticas
como la diversidad y peso molecular, el coste de los suministros,
la toxicidad, la absorci&#243;n, la distribuci&#243;n y el metabolismo. Si el
objetivo es encontrar mol&#233;culas similares a una mol&#233;cula existente
con una funci&#243;n conocida (un m&#233;todo com&#250;n en el dise&#241;o de nuevos f&#225;rmacos),
tambi&#233;n se puede tener en cuenta la similaridad estructural. Este
art&#237;culo presenta un enfoque multiobjetivo, donde puede desarrollarse
un conjunto de resultados paretianos que maximicen o minimicen cada
uno de estos objetivos. El autor concluye diciendo que el AG fue capaz
de satisfacer simult&#225;neamente los criterios de diversidad molecular
y eficiencia sint&#233;tica m&#225;xima, y tambi&#233;n fue capaz de encontrar mol&#233;culas
parecidas a un f&#225;rmaco que eran ``muy similares a las mol&#233;culas objetivo
dadas, tras explorar una fracci&#243;n muy peque&#241;a del espacio de b&#250;squeda
total'' (p. 378).

<P>
En un art&#237;culo relacionado, Glen y Payne 1995[<A
 HREF="algen.html#key-28">28</A>] describen
el uso de algoritmos gen&#233;ticos para dise&#241;ar autom&#225;ticamente mol&#233;culas
nuevas desde cero que se ajustan a un conjunto de especificaciones
dado. Dada una poblaci&#243;n inicial, bien generada aleatoriamente o utilizando
la sencilla mol&#233;cula del etano como semilla, el AG a&#241;ade, elimina
y altera aleatoriamente &#225;tomos y fragmentos moleculares con el objetivo
de generar mol&#233;culas que se ajusten a los requisitos dados. El AG
puede optimizar simult&#225;neamente un gran n&#250;mero de objetivos, incluyendo
el peso molecular, el volumen molecular, el n&#250;mero de enlaces, el
n&#250;mero de centros quirales, el n&#250;mero de &#225;tomos, el n&#250;mero de enlaces
rotables, la polarizabilidad, el momento dipolar, etc&#233;tera, para producer
mol&#233;culas candidatas con las propiedades deseadas. Bas&#225;ndose en pruebas
experimentales, incluyendo un dif&#237;cil problema de optimizaci&#243;n que
implicaba la generaci&#243;n de mol&#233;culas con propiedades similares a la
ribosa (un componente del az&#250;car imitado a menudo en los f&#225;rmacos
antivirales), los autores concluyen que el AG es un ``excelente generador
de ideas'' (p. 199) que ofrece ``propiedades de optimizaci&#243;n r&#225;pidas
y poderosas'' y puede generar ``un conjunto diverso de estructuras
posibles'' (p. 182). Contin&#250;an afirmando: ``Es de inter&#233;s especial
la poderosa capacidad de optimizaci&#243;n del algoritmo gen&#233;tico, incluso
con tama&#241;os de poblaci&#243;n relativamente peque&#241;os'' (p. 200). Como prueba
de que estos resultados no son simplemente te&#243;ricos, Lemley 2001[<A
 HREF="algen.html#key-45">45</A>]
informa de que la empresa Unilever ha utilizado algoritmos gen&#233;ticos
para dise&#241;ar nuevos componentes antimicrobianos para su uso en productos
de limpieza, algo que ha patentado.

<P>

<H2><A NAME="SECTION00065000000000000000">
Ingenier&#237;a el&#233;ctrica</A>
</H2>

<P>
Una matriz de puertas programable en campo (Field Programmable Gate
Array, o FPGA), es un tipo especial de placa de circuito con una matriz
de celdas l&#243;gicas, cada una de las cuales puede actuar como cualquier
tipo de puerta l&#243;gica, interconectado con conexiones flexibles que
pueden conectar celdas. Estas dos funciones se controlan por software,
as&#237; que simplemente cargando un programa especial en la placa, puede
alterarse al vuelo para realizar las funciones de cualquier dispositivo
de hardware de la amplia variedad existente.

<P>
El Dr. Adrian Thompson ha explotado este dispositivo, en conjunci&#243;n
con los principios de la evoluci&#243;n, para producir un prototipo de
circuito reconocedor de voz que puede distinguir y responder a &#243;rdenes
habladas utilizando s&#243;lo 37 puertas l&#243;gicas -una tarea que se habr&#237;a
considerado imposible para cualquier ingeniero humano. Gener&#243; cadenas
aleatorias de bits de ceros y unos y las utiliz&#243; como configuraciones
de la FPGA, seleccionando los individuos m&#225;s aptos de cada generaci&#243;n,
reproduci&#233;ndolos y mut&#225;ndolos aleatoriamente, intercambiando secciones
de su c&#243;digo y pas&#225;ndolo hacia la siguiente ronda de selecci&#243;n. Su
objetivo era evolucionar un dispositivo que pudiera en principio discriminar
entre tonos de frecuencias distintas (1 y 10 kilohercios), y luego
distinguir entre las palabras habladas ``go'' (adelante) y ``stop''
(para).

<P>
Su objetivo se alcanz&#243; en 3.000 generaciones, pero el &#233;xito fue mayor
de lo que hab&#237;a anticipado. El sistema que evolucion&#243; utilizaba muchas
menos celdas que cualquier cosa que pudiera haber dise&#241;ado un ingeniero
humano, y ni siquiera necesita del componente m&#225;s cr&#237;tico de los sistemas
dise&#241;ados por humanos -un reloj. &#191;C&#243;mo funcionaba? Thompson no tiene
ni idea, aunque ha rastreado la se&#241;al de entrada a trav&#233;s de un complejo
sistema de bucles realimentados del circuito evolucionado. De hecho,
de las 37 puertas l&#243;gicas que utiliza el producto final, cinco de
ellas ni siquiera est&#225;n conectadas al resto del circuito de ninguna
manera -pero si se les retira la alimentaci&#243;n el&#233;ctrica, el circuito
deja de funcionar. Parece que la evoluci&#243;n ha explotado alg&#250;n sutil
efecto electromagn&#233;tico de estas celdas para alcanzar su soluci&#243;n,
pero el funcionamiento exacto de la compleja e intrincada estructura
evolucionada sigue siendo un misterio (Davidson 1997[<A
 HREF="algen.html#key-19">19</A>]).

<P>
Altshuler y Linden 1997[<A
 HREF="algen.html#key-2">2</A>] utilizaron un algoritmo gen&#233;tico
para evolucionar antenas de alambre con propiedades especificadas
a priori. Los autores se&#241;alan que el dise&#241;o de tales antenas es un
proceso impreciso, comenzando con las propiedades deseadas y luego
determinando la forma de la antena mediante ``conjeturas...
intuici&#243;n, experiencia, ecuaciones aproximadas o estudios emp&#237;ricos''
(p. 50). Esta t&#233;cnica requiere mucho tiempo, a menudo no produce resultados
&#243;ptimos y tiende a funcionar bien s&#243;lo con dise&#241;os sim&#233;tricos y relativamente
simples. En contraste, con el m&#233;todo del algoritmo gen&#233;tico, el ingeniero
especifica las propiedades electromagn&#233;ticas de la antena, y el AG
sintetiza autom&#225;ticamente una configuraci&#243;n que sirva.

<P>

<DIV ALIGN="CENTER"><A NAME="160"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
Una antena gen&#233;tica de alambre doblado (de Altshuler y Linden 1997,
figura 1).</CAPTION>
<TR><TD><IMG
  WIDTH="192" HEIGHT="224" ALIGN="BOTTOM" BORDER="0"
 SRC="./genantenna.jpg"
 ALT="Image genantenna">

<P></TD></TR>
</TABLE>
</DIV>

<P>
Altshuler y Linden utilizaron su AG para dise&#241;ar una antena de siete
segmentos polarizada circularmente con una cobertura hemisf&#233;rica;
el resultado se muestra a la izquierda. Cada individuo del AG consist&#237;a
en un cromosoma binario que especificaba las coordenadas tridimensionales
de cada extremo final de cada alambre. La aptitud se evaluaba simulando
a cada candidato de acuerdo con un c&#243;digo de cableado electromagn&#233;tico,
y el individuo mejor de cada ronda se constru&#237;a y probaba. Los autores
describen la forma de esta antena, que no se parece a las antenas
tradicionales y carece de una simetr&#237;a obvia, como ``inusualmente
extra&#241;a'' y ``antiintuitiva'' (p. 52), aunque ten&#237;a un patr&#243;n de radiaci&#243;n
casi uniforme y con un gran ancho de banda tanto en la simulaci&#243;n
como en la prueba experimental, adecu&#225;ndose excelentemente a la especificaci&#243;n
inicial. Los autores concluyen que un m&#233;todo basado en algoritmos
gen&#233;ticos para dise&#241;ar antenas se muestra ``excepcionalmente prometedor''.
``... este nuevo procedimiento de dise&#241;o es capaz de encontrar antenas
gen&#233;ticas capaces de resolver de manera efectiva dif&#237;ciles problemas
de antenas, y ser&#225; especialmente &#250;til en situaciones en las que los
dise&#241;os existentes no sean adecuados'' (p. 52).

<P>

<H2><A NAME="SECTION00066000000000000000">
Mercados financieros</A>
</H2>

<P>
Mahfoud y Mani 1996[<A
 HREF="algen.html#key-46">46</A>] utilizaron un algoritmo gen&#233;tico
para predecir el rendimiento futuro de 1.600 acciones ofertadas p&#250;blicamente.
Concretamente, al AG se le asign&#243; la tarea de predecir el beneficio
relativo de cada acci&#243;n, definido como el beneficio de esa acci&#243;n
menos el beneficio medio de las 1.600 acciones a lo largo del periodo
de tiempo en cuesti&#243;n, 12 semanas (un cuarto del calendario) en el
futuro. Como entrada, al AG se le proporcionaron datos hist&#243;ricos
de cada acci&#243;n en forma de una lista de 15 atributos, como la relaci&#243;n
precio-beneficio y el ritmo de crecimiento, medidos en varios puntos
del tiempo pasado; se le pidi&#243; al AG que evolucionara un conjunto
de reglas si/entonces para clasificar cada acci&#243;n y proporcionar,
como salida, una recomendaci&#243;n sobre qu&#233; hacer con respecto a la acci&#243;n
(comprar, vender o ninguna predicci&#243;n) y un pron&#243;stico num&#233;rico del
beneficio relativo. Los resultados del AG fueron comparados con los
de un sistema establecido, basado en una red neuronal, que los autores
hab&#237;an estado utilizando para pronosticar los precios de las acciones
y administrar las carteras de valores durante tres a&#241;os. Por supuesto,
el mercado de valores es un sistema extremadamente ruidoso y no lineal,
y ning&#250;n mecanismo predictivo puede ser correcto el 100% del tiempo;
el reto consiste en encontrar un predictor que sea preciso m&#225;s de
la mitad de las veces. 

<P>
En el experiemnto, el AG y la red neuronal hicieron pron&#243;sticos al
final de la semana para cada una de las 1.600 acciones, durante doce
semanas consecutivas. Doce semanas despu&#233;s de cada predicci&#243;n, se
compar&#243; el rendimiento verdadero con el beneficio relativo predicho.
Globalmente, el AG super&#243; significativamente a la red neuronal: en
una ejecuci&#243;n de prueba, el AG predijo correctamente la direcci&#243;n
de una acci&#243;n el 47,6% de las veces, no hizo predicci&#243;n el 45,8%
de las veces y realiz&#243; una predicci&#243;n incorrecta s&#243;lo un 6.6% de
las veces, una precisi&#243;n predictiva total de un 87,8%. Aunque la
red neuronal realiz&#243; predicciones precisas m&#225;s a menudo, tambi&#233;n hizo
predicciones err&#243;neas m&#225;s a menudo (de hecho, los autores especulan
que la mayor capacidad del AG para no realizar predicciones cuando
los datos eran dudosos fue un factor de su &#233;xito; la red neuronal
siempre produce una predicci&#243;n a menos que sea restringida expl&#237;citamente
por el programador). En el experimento de las 1.600 acciones, el AG
produjo un beneficio relativo de un +5,47%, contra el +4,40% de
la red neuronal -una diferencia estad&#237;sticamente significativa. De
hecho, el AG tambi&#233;n super&#243; significativamente a tres &#237;ndices burs&#225;tiles
importantes -el S&amp;P 500, el S&amp;P 400 y el Russell 2000-
en este periodo; la casualidad fue exclu&#237;da como causa de este resultado
con un margen de confianza de un 95%. Los autores atribuyen este
convincente &#233;xito a la capacidad del algoritmo gen&#233;tico de percatarse
de relaciones no lineales dif&#237;cilmente evidentes para los observadores
humanos, adem&#225;s del hecho de que carece del ``prejuicio contra las
reglas antiintuitivas y contradictorias'' (p. 562) de los expertos
humanos.

<P>
Andreou, Georgopoulos y Likothanassis 2002[<A
 HREF="algen.html#key-4">4</A>] lograron un
&#233;xito similar utilizando algoritmos gen&#233;ticos h&#237;bridos para evolucionar
redes neuronales que predijeran los tipos de cambio de monedas extranjeras
hasta un mes en el futuro. Al contrario que en el ejemplo anterior,
donde compet&#237;an AGs y redes neuronales, aqu&#237; los dos trabajaron conjuntamente:
el AG evolucion&#243; la arquitectura (n&#250;mero de unidades de entrada, n&#250;mero
de unidades ocultas y la estructura de enlaces entre ellas) de la
red, que luego era entrenada por un algoritmo de filtro.

<P>
Se le proporciaron al algoritmo 1.300 valores brutos diarios de cinco
divisas como informaci&#243;n hist&#243;rica -el d&#243;lar estadounidense, el marco
alem&#225;n, el franco franc&#233;s, la libra esterlina y el dracma griego-
y se le pidi&#243; que predijera sus valores futuros para los 1, 2, 5 y
20 d&#237;as posteriores. El rendimiento del AG h&#237;brido mostr&#243;, en general,
un ``nivel excepcional de precisi&#243;n'' (p. 200) en todos los casos
probados, superando a otros varios m&#233;todos, incluyendo a las redes
neuronales en solitario. Los autores concluyen que ``se ha logrado
un excepcional &#233;xito predictivo tanto con un horizonte predictivo
de un paso como de varios pasos'' (p. 208) -de hecho, afirman que
sus resultados son mejores con diferencia que cualquier estrategia
predictiva relacionada que se haya aplicado en esta serie de datos
u otras divisas. 

<P>
La utilizaci&#243;n de los AGs en los mercados financieros ha empezado
a extenderse en las empresas de corretaje burs&#225;til del mundo real.
Naik 1996[<A
 HREF="algen.html#key-48">48</A>] informa de que LBS Capital Management, una
empresa estadounidense cons ede en Florida, utiliza algoritmos gen&#233;ticos
para escoger las acciones de los fondos de pensiones que administra.
Coale 1997[<A
 HREF="algen.html#key-17">17</A>] y Begley y Beals 1995[<A
 HREF="algen.html#key-9">9</A>] informan
de que First Quadrant, una empresa de inversiones de Californa que
mueve m&#225;s de 2.200 millones de d&#243;lares, utiliza AGs para tomar decisiones
de inversi&#243;n en todos sus servicios financieros. Su modelo evolucionado
gana, de media, 225 d&#243;lares por cada 100 d&#243;lares invertidos durante
seis a&#241;os, en contraste con los 205 d&#243;lares de otros tipos de sistemas
de modelos.

<P>

<H2><A NAME="SECTION00067000000000000000">
Juegos</A>
</H2>

<P>
Una de las demostraciones m&#225;s novedosas y persuasivas de la potencia
de los algoritmos gen&#233;ticos la presentaron Chellapilla y Fogel 2001[<A
 HREF="algen.html#key-13">13</A>],
que utilizaron un AG para evolucionar redes neuronales que pudieran
jugar a las damas. Los autores afirman que una de las mayores dificultades
en este tipo de problemas relacionados con estrategias es el problema
de la asignaci&#243;n de cr&#233;dito -en otras palabras, &#191;c&#243;mo escribir una
funci&#243;n de aptitud? Se ha cre&#237;do ampliamente que los criterios simples
de ganar, perder o empatar no proporcionan la suficiente informaci&#243;n
para que un algoritmo gen&#233;tico averig&#252;e qu&#233; constituye el buen juego.

<P>
En este art&#237;culo, Chellapila y Fogel echan por tierra esa suposici&#243;n.
Dados s&#243;lo las posiciones espaciales de las piezas en el tablero y
el n&#250;mero total de piezas que posee cada jugador, fueron capaces de
evolucionar un programa de damas que jugaba a un nivel competitivo
con expertos humanos, sin ninguna informaci&#243;n de entrada inteligente
acerca de lo que constituye el buen juego -es m&#225;s, ni siquiera se
les dijo a los individuos del algoritmo evolutivo cu&#225;l era el criterio
para ganar, ni se les dijo el resultado de ning&#250;n juego. 

<P>
En la representaci&#243;n de Chellapilla y Fogel, el estado del juego estaba
representado por una lista num&#233;rica de 32 elementos, en donde cada
posici&#243;n de la lista correspond&#237;a a una posici&#243;n disponible en el
tablero. El valor de cada posici&#243;n era 0 para una casilla desocupada,
-1 si esa casilla estaba ocupada por una pieza enemiga, +1 si la casilla
estaba ocupada por una de las piezas del programa, y -K o +K si la
casilla estaba ocupada por una dama enemiga o amiga. (El valor de
K no se especificaba a priori, sino que, de nuevo, era determinado
por la evoluci&#243;n durante el curso del algoritmo). Acompa&#241;ando a todo
esto hab&#237;a una red neuronal con m&#250;ltiples capas de procesamiento y
una capa de entrada con un nodo para cada una de las 4x4, 5x5, 6x6,
7x7 y 8x8 posibles casillas del tablero. La salida de la red neuronal
para una colocaci&#243;n de las piezas dada era un valor entre -1 y +1,
que indicaba c&#243;mo de buena le parec&#237;a esa posici&#243;n. Para cada movimiento,
se le presentaba a la red neuronal un &#225;rbol de juego que conten&#237;a
todos los movimientos posibles hasta cuatro turnos en el futuro, y
el movimiento se decid&#237;a bas&#225;ndose en qu&#233; rama del &#225;rbol produc&#237;a
los mejores resultados.

<P>
El algoritmo evolutivo comenz&#243; con una poblaci&#243;n de 15 redes neuronales
con pesos y tendencias, generados aleatoriamente, asignados a cada
nodo y conexi&#243;n; luego, cada individuo se reprodujo una vez, generando
una descendencia con variaciones en los valores de la red. Luego estos
30 individuos compitieron por la supervivencia jugando entre ellos;
cada individuo compiti&#243; en cada turno con 5 oponentes elegidos aleatoriamente.
Se otorg&#243; 1 punto a cada victoria y se descontaban 2 puntos por cada
derrota. Se seleccionaron los 15 mejores jugadores en relaci&#243;n a su
puntuaci&#243;n total, y el proceso se repiti&#243;. La evoluci&#243;n continu&#243; durante
840 generaciones m&#225;s (aproximadamente seis meses de tiempo de computaci&#243;n).

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">Clase</TD>
<TD ALIGN="CENTER">Puntuaci&#243;n</TD>
</TR>
<TR><TD ALIGN="CENTER">Gran Maestro</TD>
<TD ALIGN="CENTER">+2.400</TD>
</TR>
<TR><TD ALIGN="CENTER">Maestro</TD>
<TD ALIGN="CENTER">2.200-2.399</TD>
</TR>
<TR><TD ALIGN="CENTER">Experto</TD>
<TD ALIGN="CENTER">2.000-2.199</TD>
</TR>
<TR><TD ALIGN="CENTER">Clase A</TD>
<TD ALIGN="CENTER">1.800-1.999</TD>
</TR>
<TR><TD ALIGN="CENTER">Clase B</TD>
<TD ALIGN="CENTER">1.600-1.799</TD>
</TR>
<TR><TD ALIGN="CENTER">Clase C</TD>
<TD ALIGN="CENTER">1.400-1.599</TD>
</TR>
<TR><TD ALIGN="CENTER">Clase J</TD>
<TD ALIGN="CENTER">&lt;200</TD>
</TR>
</TABLE>

<P>
El mejor individuo que surgi&#243; de esta selecci&#243;n fue inscrito como
competidor en la p&#225;gina web de juegos <tt>http://www.zone.com</tt>.
Durante un periodo de dos meses, jug&#243; contra 165 oponentes humanos
que compon&#237;an una gama de niveles altos, desde clase C a maestros,
de acuerdo con el sistema de clasificaciones de la Federaci&#243;n de Ajedrez
de Estados Unidos (mostrado a la izquierda, con algunos rangos omitidos
en aras de claridad). De estas partidas, la red neuronal gan&#243; 94,
perdi&#243; 39 y empat&#243; 32; en base a las clasificaciones de los oponentes
en estas partidas, la red neuronal evolucionada era equivalente a
un jugador con una puntuaci&#243;n media de 2.045,85, coloc&#225;ndola en el
nivel experto -una clasificaci&#243;n superior a la del 99,61% de los
80.000 jugadores registrados en la p&#225;gina web. Una de las victorias
m&#225;s significativas de la red neuronal fue cuando venci&#243; a un jugador
clasificado en la posici&#243;n 98 de todos los jugadores registrados,
cuya puntuaci&#243;n estaba tan s&#243;lo 27 puntos por debajo del nivel de
maestro.

<P>
Las pruebas realizadas con un sencillo programa diferencial en las
piezas (que basa sus movimientos solamente en la diferencia entre
el n&#250;mero de piezas que quedan en cada lado) con una capacidad de
anticipaci&#243;n de 8 movimientos demostr&#243; que la red neuronal era significativamente
superior, con una puntuaci&#243;n de m&#225;s de 400 puntos por encima. ``Un
programa que se basa s&#243;lo en el n&#250;mero de piezas y en una b&#250;squeda
de ocho capas vencer&#225; a muchas personas, pero no es un experto. La
mejor red neuronal evolucionada s&#237; lo es'' (p. 425). Aunque pod&#237;a
buscar posiciones dos movimientos m&#225;s lejos que la red neuronal, el
programa diferencial en las piezas perdi&#243; contundentemente 8 de 10
partidas. Esto demuestra concluyentemente que la red neuronal evolucionada
no s&#243;lo est&#225; contando piezas, sino que de alguna manera procesa las
caracter&#237;sticas espaciales del tablero para decidir sus movimientos.
Los autores se&#241;alan que los oponentes de zone.com que los movimientos
de la red neuronal eran ``extra&#241;os'', pero su nivel global de juego
fue descrito como ``muy duro'' o con t&#233;rminos elogiosos similares.

<P>
Para probar m&#225;s a la red neuronal evolucionada (a la que los autores
nombraron ``Anaconda'' porque a menudo ganaba restringiendo la movilidad
de sus oponentes), jug&#243; contra un programa de damas comercial, el
Hoyle Classic Games, distribu&#237;do por Sierra Online (Chellapilla y
Fogel 2000[<A
 HREF="algen.html#key-14">14</A>]). Este programa viene con un surtido de personajes
incorporados, cada uno con un nivel de juego distinto. Anaconda se
puso a prueba con tres personajes (``Beatrice'', ``Natasha'' y ``Leopold'')
designados como jugadores expertos, jugando una partida con las rojas
y otra partida con las blancas contra cada uno de ellos con una capacidad
de anticipaci&#243;n de 6 movimientos. Aunque los autores dudaban de que
esta profundidad de anticipaci&#243;n pudiera darla a Anaconda la capacidad
de juego experto que demostr&#243; anteriormente, consigui&#243; seis victorias
seguidas de las seis partidas jugadas. Bas&#225;ndose en este resultado,
los autores expresaron escepticismo sobre si el software Hoyle jugaba
al nivel que anunciaba, &#161;aunque debe se&#241;alarse que llegaron a esta
conclusi&#243;n bas&#225;ndose solamente en la facilidad con la que Anaconda
le venci&#243;!

<P>
La prueba definitiva de Anaconda se detalla en Chellapilla y Fogel
2002[<A
 HREF="algen.html#key-15">15</A>], cuando la red neuronal evolucionada jug&#243; contra
el mejor jugador de damas del mundo: <a href="http://www.cs.ualberta.ca/chinook">Chinook</a>,
un programa dise&#241;ado principalmente por el Dr. Jonathan Schaeffer,
de la Universidad de Alberta. Con una puntuaci&#243;n de 2.814 en 1996
(mientras que sus competidores humanos m&#225;s cercanos andan por los
2.600), Chinook incorpora un libro de movimientos de apertura proporcionado
por grandes maestros humanos, un conjunto sofisticado de algoritmos
de juego para la parte central de la partida, y una base de datos
completa de todos los movimientos posibles cuando quedan en el tablero
10 piezas o menos, de manera que nunca comete un error durante un
final de partida. Se invirti&#243; una cantidad enorme de inteligencia
y experiencia humana en el dise&#241;o de este programa.

<P>
Chellapilla y Fogel enfrentaron a Anaconda y Chinook en un torneo
de 10 partidas, con Chinook jugando al nivel de 5 capas de anticipaci&#243;n,
aproxim&#225;ndolo m&#225;s o menos al nivel de maestro. Chinook gan&#243; esta competici&#243;n,
cuatro victorias a dos, con cuatro empates. (Curiosamente, como se&#241;alan
los autores, en dos de las partidas que acabaron con empate, Anaconda
lideraba con cuatro damas mientras que Chinook ten&#237;a tres. Adem&#225;s,
una de las victorias de Chinook vino tras una serie de movimientos
con b&#250;squeda de 10 capas sacados de su base de datos de finales de
partida; unos movimientos que Anaconda, con una anticipaci&#243;n de 8
capas, no pudo anticipar. Si Anaconda hubiera tenido acceso a una
base de datos de finales de partida de la misma calidad de la de Chinook,
el resultado del torneo bien podr&#237;a haber sido el de victoria para
Anaconda, cuatro a tres). Estos resultados ``proporcionan un buen
sustento a la puntuaci&#243;n de experto que se gan&#243; Anaconda en www.zone.com''
(p. 76), con una puntuaci&#243;n global de 2.030-2.055, comparable a la
puntuaci&#243;n de 2.045 que gan&#243; jugando contra humanos. Aunque Anaconda
no es un jugador invulnerable, es capaz de jugar competitivamente
en el nivel experto y comportarse ante una variedad de jugadores de
damas humanos extremadamente h&#225;biles. Cuando uno considera los criterios
de aptitud tan sencillos con los que se obtuvieron estos resultados,
el surgimiento de Anaconda proporciona una espectacular corroboraci&#243;n
del poder de la evoluci&#243;n.

<P>

<H2><A NAME="SECTION00068000000000000000">
Geof&#237;sica</A>
</H2>

<P>
Sambridge y Gallaguer 1993[<A
 HREF="algen.html#key-56">56</A>] utilizaron un algoritmo gen&#233;tico
para los hipocentros de los terremotos bas&#225;ndose en datos sismol&#243;gicos.
(El hipocentro es el punto bajo la superficie terrestre en el que
se origina un terremoto. El epicentro es el punto de la superficie
directamente encima del hipocentro). Esto es una tarea sumamente compleja,
ya que las propiedades de las ondas s&#237;smicas dependen de las propiedades
de las capas de roca a trav&#233;s de las que viajan. El m&#233;todo tradicional
para localizar el hipocentro se basa en lo que se conoce como algoritmo
de inversi&#243;n s&#237;smico, que empieza con la mejor estimaci&#243;n de la ubicaci&#243;n,
calcula las derivadas del tiempo de viaje de la onda con respecto
al punto de origen, y realiza una operaci&#243;n de matriz para proporcionar
una ubicaci&#243;n actualizada. Este proceso se repite hasta que se alcanza
una soluci&#243;n aceptable. (Este <a href="http://www.talkorigins.org/origins/postmonth/nov03.html">
Mensaje del Mes</a>,
de noviembre de 2003, proporciona m&#225;s informaci&#243;n). Sin embargo, este
m&#233;todo requiere informaci&#243;n diferencial y es propenso a quedar atrapado
en &#243;ptimos locales.

<P>
Un algoritmo de localizaci&#243;n que no dependa de informaci&#243;n diferencial
o modelos de velocidad puede evitar esta deficiencia calculando s&#243;lo
el problema directo -la diferencia entre los tiempos de llegada de
la onda observados y predichos para distintas localizaciones del hipocentro.
Sin embargo, un m&#233;todo de b&#250;squeda exhaustivo basado en este m&#233;todo
ser&#237;a demasiado costoso computacionalmente. &#201;ste, por supuesto, es
precisamente el tipo de problema de optimizaci&#243;n en el que destacan
los algoritmos gen&#233;ticos. Como todos los AGs, el propuesto por el
art&#237;culo citado es paralelo en naturaleza -en lugar de mover un solo
hipocentro m&#225;s y m&#225;s cerca hacia la soluci&#243;n, comienza con una nube
de hipocentros potenciales que encoge con el tiempo hasta converger
en una sola soluci&#243;n. Los autores afirman que su m&#233;todo ``puede localizar
r&#225;pidamente soluciones casi &#243;ptimas sin una b&#250;squeda exhaustiva del
espacio de par&#225;metros'' (p. 1.467), muestra ``un comportamiento muy
organizado que produce una b&#250;squeda eficiente'' y es ``un compromiso
entre la eficiencia de los m&#233;todos basados en derivadas y la robustez
de una b&#250;squeda exhaustiva completamente no lineal'' (p. 1.469). Los
autores concluyen que su algoritmo gen&#233;tico es ``eficiente para una
verdadera optimizaci&#243;n global'' (p. 1.488) y ``una herramienta nueva
y poderosa para realizar b&#250;squedas robustas de hipocentros'' (p. 1.489).

<P>

<H2><A NAME="SECTION00069000000000000000">
Ingenier&#237;a de materiales</A>
</H2>

<P>
Giro, Cyrillo y Galv&#227;o 2002[<A
 HREF="algen.html#key-27">27</A>] utilizaron algoritmos gen&#233;ticos
para dise&#241;ar pol&#237;meros conductores de electricidad basados en el carbono,
conocicos como polianilinas. Estos pol&#237;meros, un tipo de material
sint&#233;tico inventado recientemente, tienen ``grandes aplicaciones tecnol&#243;gicas
potenciales'' y podr&#237;an abrir la puerta a ``nuevos fen&#243;menos f&#237;sicos
fundamentales'' (p. 170). Sin embargo, debido a su alta reactividad,
los &#225;tomos de carbono pueden formar un n&#250;mero virtualmente infinito
de estructuras, haciendo que la b&#250;squeda de nuevas mol&#233;culas con propiedades
interesantes sea del todo imposible. En este art&#237;culo, los autores
aplican un enfoque basado en AGs a la tarea de dise&#241;ar mol&#233;culas nuevas
con propiedades especificadas a priori, comenzando con una poblaci&#243;n
de candidatos iniciales generada aleatoriamente. Concluyen que su
metodolog&#237;a puede ser una ``herramienta muy efectiva'' (p. 174) para
guiar a los investigadores en la b&#250;squeda de nuevos compuestos y es
lo suficientemente general para que pueda extenderse al dise&#241;o de
nuevos materiales que pertenezcan virtualmente a cualquier tipo de
mol&#233;cula.

<P>
Weismann, Hammel, y B&#228;ck 1998[<A
 HREF="algen.html#key-63">63</A>] aplicaron algoritmos evolutivos
a un problema industrial ``no trivial'' (p. 162): el dise&#241;o de revestimientos
&#243;pticos multicapa para filtros que reflejan, transmiten o absorben
luz de frecuencias especificadas. Estos revestimientos se utilizan
en la fabricaci&#243;n de gafas de sol, por ejemplo, o discos compactos.
Su fabricaci&#243;n es una tarea precisa: las capas deben colocarse en
una secuencia particular y con un grosor particular para producir
el resultado deseado, y las variaciones incontrolables del entorno
de fabricaci&#243;n, como la temperatura, la poluci&#243;n o la humedad, pueden
afectar al rendimiento del producto acabado. Muchos &#243;ptimos locales
no son robustos ante estas variaciones, lo que significa que una mayor
calidad del producto se paga con una tasa mayor de desviaciones indeseadas.
El problema particular considerado en este art&#237;culo tambi&#233;n ten&#237;a
m&#250;ltiples criterios: adem&#225;s de la reflectancia, tambi&#233;n se consider&#243;
la composici&#243;n espectral (color) de la luz reflejada.

<P>
El AE actu&#243; variando el n&#250;mero de capas de revestimiento y el grosor
de cada una de ellas, y produjo dise&#241;os que eran ``sustancialmente
m&#225;s robustos a la variaci&#243;n de par&#225;metros'' (p. 166) y ten&#237;an un rendimiento
medio mayor que los m&#233;todos tradicionales. Los autores concluyen que
``los algoritmos evolutivos pueden competir e incluso superar a los
m&#233;todos tradicionales'' (p. 167) de dise&#241;o de revestimientos &#243;pticos
multicapa, sin tener que incorporar un conocimiento espec&#237;fico del
dominio en la funci&#243;n de b&#250;squeda y sin tener que alimentar a la poblaci&#243;n
con buenos dise&#241;os iniciales.

<P>
Es digno de menci&#243;n otro uso de los AGs en el campo de la ingenier&#237;a
de materiales: Robin et al. 2003[<A
 HREF="algen.html#key-54">54</A>] utilizaron AGs para
dise&#241;ar patrones de exposici&#243;n para un haz de electrones de litograf&#237;a,
utilizado para grabar estructuras a una escala menor a la del micr&#243;metro
en circuitos integrados. Dise&#241;ar estos patrones es una tarea muy dif&#237;cil;
es pesado y costoso determinarlos experimentalmente, pero la alta
dimensionalidad del espacio de b&#250;squeda frustra a la mayor&#237;a de los
algoritmos de b&#250;squeda. Deben optimizarse simult&#225;neamente hasta 100
par&#225;metros para controlar el haz de electrones y evitar la dispersi&#243;n
y efectos de proximidad que arruinar&#237;an las estructuras finas que
se est&#233;n esculpiendo. El problema directo -determinar la estructura
resultante como funci&#243;n de la cantidad de electrones- es sencillo
y f&#225;cil de simular, pero el problema inverso de determinar la cantidad
de electrones para producir una estructura dada, que es lo que se
pretende resolver aqu&#237;, es mucho m&#225;s dif&#237;cil y no existe una soluci&#243;n
determinista.

<P>
Se aplicaron algoritmos gen&#233;ticos a este problema, ya que ``se sabe
que son capaces de encontrar soluciones buenas a problemas muy complejos
de alta dimensionalidad'' (p. 75) sin necesidad de proporcionarles
informaci&#243;n espec&#237;fica del dominio acerca de la topolog&#237;a del paisaje
de b&#250;squeda. Los autores del art&#237;culo emplearon un AG de estado estacionario
con selecci&#243;n por rueda de ruleta en una simulaci&#243;n por computador,
que produjo unos patrones de exposici&#243;n ``muy bien optimizados'' (p.
77). En contraste, se utiliz&#243; un tipo de trepacolinas conocido como
algoritmo bajacolinas-simplex (simplex-downhill) en el mismo problema,
sin &#233;xito; el m&#233;todo BS quedaba r&#225;pidamente atrapado en &#243;ptimos locales
de los que no pod&#237;a escapar, produciendo soluciones de poca calidad.
Un h&#237;brido entre los m&#233;todos del AG y el BS tampoco pudo mejorar los
resultados ofrecidos por el AG en solitario.

<P>

<H2><A NAME="SECTION000610000000000000000">
Matem&#225;ticas y algoritmia</A>
</H2>

<P>
Aunque algunas de las aplicaciones m&#225;s prometedoras y las demostraciones
m&#225;s convincentes de la potencia de los AGs se encuentran en el campo
de la ingenier&#237;a de dise&#241;o, tambi&#233;n son relevantes en problemas ``puramente''
matem&#225;ticos. Haupt y Haupt 1998[<A
 HREF="algen.html#key-34">34</A>] (p. 140) describen el
uso de AGs para resolver ecuaciones de derivadas parciales no lineales
de alto orden, normalmente encontrando los valores para los que las
ecuaciones se hacen cero, y dan como ejemplo una soluci&#243;n casi perfecta
para los coeficientes de la ecuaci&#243;n de quinto orden conocida como
Super Korteweg-de Vries.

<P>
Ordenar una lista de elementos es una tarea importante en la inform&#225;tica,
y una red de ordenaci&#243;n es una manera eficiente de conseguirlo. Una
red de ordenaci&#243;n es una lista fija de comparaciones realizadas en
un conjunto de un tama&#241;o dado; en cada comparaci&#243;n se comparan dos
elementos y se intercambian si no est&#225;n en orden. Koza et al. 1999[<A
 HREF="algen.html#key-41">41</A>]
(p. 952) utilizaron programaci&#243;n gen&#233;tica para evolucionar redes de
ordenaci&#243;n m&#237;nimas para conjuntos de 7 elementos (16 comparaciones),
conjuntos de 8 elementos (19 comparaciones) y conjuntos de 9 elementos
(25 comparaciones). Mitchell 1996[<A
 HREF="algen.html#key-47">47</A>], p. 21, describe el
uso de algoritmos gen&#233;ticos por W. Daniel Hillis para encontrar una
red de ordenaci&#243;n de 61 comparaciones para un conjunto de 16 elementos,
s&#243;lo un paso m&#225;s all&#225; de la m&#225;s peque&#241;a conocida. Este &#250;ltimo ejemplo
es especialmente interesante por las dos innovaciones que utiliza:
cromosomas diploides y, m&#225;s notablemente, coevoluci&#243;n de hu&#233;sped/par&#225;sito.
Tanto las redes de b&#250;squeda como los casos de prueba evolucionaron
conjuntamente; se les otorg&#243; mayor aptitud a las redes de ordenaci&#243;n
que ordenaran correctamente un mayor n&#250;mero de casos de prueba, mientras
que se les otorg&#243; mayor aptitud a los casos de prueba que pudieran
``enga&#241;ar'' a un mayor n&#250;mero de redes de b&#250;squeda para que ordenaran
incorrectamente. El AG con coevoluci&#243;n rindi&#243; significativamente mejor
que el mismo AG sin ella.

<P>
Un ejemplo final de AG digno de menci&#243;n en el campo de la algoritmia
puede encontrarse en Koza et al. 1999[<A
 HREF="algen.html#key-41">41</A>], que utiliz&#243; programaci&#243;n
gen&#233;tica para descubrir una regla para el problema de clasificaci&#243;n
por mayor&#237;a en aut&#243;matas celulares de una dimensi&#243;n, una regla mejor
que todas las reglas conocidas escritas por humanos. Un aut&#243;mata celular
de una dimensi&#243;n puede imaginarse como una cinta finita con un n&#250;mero
dado de posiciones (celdas) en ella, cada una de las cuales puede
contener el estado 0 o el estado 1. El aut&#243;mata se ejecuta durante
un n&#250;mero dado de pasos temporales; en cada paso, cada celda adquiere
un nuevo valor basado en su valor anterior y el valor de sus vecinos
m&#225;s cercanos. (El <a href="http://www.math.com/students/wonders/life/life.html">Juego
de la Vida</a>
es un aut&#243;mata celular bidimensional). El problema de la clasificaci&#243;n
por mayor&#237;a implica encontrar una tabla de reglas tal que si m&#225;s de
la mitad de las celdas de la cinta son 1 inicialmente, todas las celdas
se ponen a 1; de lo contrario, todas las celdas se ponen a 0. El reto
consiste en el hecho de que cualquier celda individual s&#243;lo tiene
acceso a informaci&#243;n acerca de sus vecinos m&#225;s cercanos; por lo tanto,
los conjuntos de reglas buenos deben encontrar de alg&#250;n modo una manera
de transmitir informaci&#243;n sobre regiones distantes de la cinta. 

<P>
Se sabe que no existe una soluci&#243;n perfecta a este problema -ning&#250;n
conjunto de reglas puede clasificar con precisi&#243;n todas las configuraciones
iniciales posibles-, pero durante los &#250;ltimos veinte a&#241;os ha habido
una larga sucesi&#243;n de soluciones cada vez mejores. En 1978, tres investigadores
desarrollaron la famosa regla GKL, que clasifica correctamente un
81,6% de los posibles estados iniciales. En 1993, se descubri&#243; una
regla mejor con una precisi&#243;n de un 81,8%; en 1995 se encontr&#243; otra
regla con una precisi&#243;n de un 82,178%. Todas estas reglas requirieron
para su desarrollo de un esfuerzo significativo por parte de humanos
inteligentes y creativos. En contraste, la mejor regla descubierta
mediante programaci&#243;n gen&#233;tica, descrito en Koza et al. 1999[<A
 HREF="algen.html#key-41">41</A>],
p. 973, tiene una precisi&#243;n total de 82,326% -mejor que cualquiera
de las soluciones humanas desarrolladas durante las dos &#250;ltimas d&#233;cadas.
Los autores se&#241;alan que sus nuevas reglas son cualitativamente distintas
a las reglas publicadas con anterioridad, al emplear representaciones
internas muy detalladas de la densidad de estados y conjuntos intrincados
de se&#241;ales para comunicar informaci&#243;n a largas distancias.

<P>

<H2><A NAME="SECTION000611000000000000000">
Ej&#233;rcito y cumplimiento de la ley</A>
</H2>

<P>
Kewley y Embrechts 2002[<A
 HREF="algen.html#key-39">39</A>] utilizaron algoritmos gen&#233;ticos
para evolucionar planes t&#225;cticos para las batallas militares. Los
autores se&#241;alan que ``planear una batalla militar t&#225;ctica es una tarea
compleja multidimensoinal que a menudo atormenta a los profesionales
experimentados'' (p. 163), no s&#243;lo porque este tipo de decisiones
a menudo se toman bajo condiciones de mucho estr&#233;s, sino tambi&#233;n porque
hasta los planes m&#225;s sencillos requieren tomar en cuenta un gran n&#250;mero
de variables y consecuencias: minimizar las bajas amigas, maximizar
las bajas enemigas, controlar el terreno deseado, conservar recursos,
etc&#233;tera. Los planificadores humanos tienen dificultades al tratar
con las complejidades de esta tarea y a menudo deben recurrir a m&#233;todos
``r&#225;pidos y sucios'', como hacer lo que funcionase la &#250;ltima vez.

<P>
Para superar estas dificultades, los autores del art&#237;culo citado desarrollaron
un algoritmo gen&#233;tico para automatizar la creaci&#243;n de planes de batalla,
en conjunci&#243;n con un programa gr&#225;fico de simulaci&#243;n de batallas. El
comandante introduce el resultado deseado y el AG evoluciona autom&#225;ticamente
un plan de batalla; en la simulaci&#243;n utilizada, se tomaron en cuenta
factores como la topograf&#237;a del terreno, la cobertura vegetal, la
velocidad del movimiento de tropas, y la precisi&#243;n en los disparos.
En este experimento tambi&#233;n se utiliz&#243; la coevoluci&#243;n para mejorar
la calidad de las soliciones: los planes de batalla de las fuerzas
enemigas evolucionaron simult&#225;neamente con los planes amigos, forzando
al AG a corregir cualquier debilidad de su plan que pudiese explotar
el enemigo. Para medir la calidad de las soluciones producidas por
el AG, se compararon con planes de batalla para el mismo escenario
producidos por un grupo de ``expertos militares experimentados...
considerados muy capaces de desarrollar planes de acci&#243;n para el tama&#241;o
de las fuerzas utilizadas en este experimento'' (p. 166). Estos avezados
expertos desarrollaron su propio plan y, cuando la soluci&#243;n del AG
estuvo acabada, se les dio la oportunidad de examinarla y modificarla
como vieran conveniente. Finalmente, todos los planes se ejecutaron
varias veces en el simulador para determinar su calidad media.

<P>
Los resultados hablan por s&#237; mismos: la soluci&#243;n evolucionada super&#243;
tanto al propio plan de los expertos militares como al plan producido
por sus modificaciones sobre la soluci&#243;n del AG. ``...Los planes
producidos por los algoritmos autom&#225;ticos ten&#237;an un rendimiento medio
significativamente mayor al de los generados por los experimentados
expertos militares'' (p. 161). Es m&#225;s, los autores se&#241;alan que el
plan del AG ten&#237;a sentido t&#225;ctico. (Consist&#237;a en un ataque a dos flancos
a la posici&#243;n enemiga por pelotones de infanter&#237;a mecanizada apoyados
por helic&#243;pteros de ataque y exploradores terrestres, en conjunci&#243;n
con veh&#237;culos a&#233;reos no tripulados realizando labores de reconocimiento
para el fuego directo de artiller&#237;a). Por a&#241;adidura, el plan evolucionado
inclu&#237;a unidades amigas individuales llevando a cabo misiones doctrinales
-una propiedad emergente que apareci&#243; durante el curso de la ejecuci&#243;n,
en lugar de ser especificada por el experimentador. En campos de batalla
modernos, cada vez m&#225;s conectados por red, el atractivo potencial
de un algoritmo evolutivo que pueda automatizar la producci&#243;n de planes
t&#225;cticos de alta calidad deber&#237;a ser obvio.

<P>
Naik 1996[<A
 HREF="algen.html#key-48">48</A>] informa de un uso interesante de los AGs en
el cumplimiento de la ley, describiendo el software ``FacePrints'',
un proyecto para ayudar a los testigos a identificar y describir a
los sospechosos criminales. La imagen clich&#233; del artista polic&#237;a haciendo
un dibujo del rostro del sospechoso en base a la descripci&#243;n de los
testigos es un m&#233;todo dif&#237;cil e ineficiente: la mayor&#237;a de la gente
no es buena describiendo aspectos individuales del rostro de una persona,
como el tama&#241;o de la nariz o la forma de la mand&#237;bula, pero sin embargo
son mejores al reconocer caras completas. FacePrints aprovecha esto
utilizando un algoritmo gen&#233;tico que evoluciona dibujos de caras bas&#225;ndose
en bases de datos de cientos de caracter&#237;sticas individuales que pueden
combinarse de infinitas maneras. El programa muestra a los testigos
im&#225;genes de rostros generadas aleatoriamente, y &#233;stos escogen las
que m&#225;s se parecen a la persona que vieron; las caras seleccionadas
mutan y se combinan para generar nuevas combinaciones de caracter&#237;sticas,
y el proceso se repite hasta que emerge un retrato preciso del rostro
del sospechoso. En un caso real de atraco, los retratos definitivos
que crearon los tres testigos eran sorprendentemente parecidos, y
el dibujo resultante apareci&#243; en el peri&#243;dico local.

<P>

<H2><A NAME="SECTION000612000000000000000">
Biolog&#237;a molecular</A>
</H2>

<P>
En los seres vivos, las prote&#237;nas transmembrana son prote&#237;nas que
sobresalen de una membrana celular. Las prote&#237;nas transmembrana realizan
a menudo funciones importantes como detectar la presencia de ciertas
sustancias en el exterior de la c&#233;lula o transportarlas hacia el interior
de la c&#233;lula. Para comprender el comportamiento de una prote&#237;na transmembrana
es necesario identificar el segmento de la prote&#237;na que realmente
est&#225; insertado en la membrana, lo que se conoce como dominio transmembrana.
Durante las dos &#250;ltimas d&#233;cadas, los bi&#243;logos moleculares han publicado
una serie de algoritmos cada vez m&#225;s precisos para este prop&#243;sito.

<P>
Todas las prote&#237;nas utilizadas por los seres vivos est&#225;n formadas
por los mismos 20 amino&#225;cidos. Algunos de estos amino&#225;cidos son hidrof&#243;bicos,
lo que significa que repelen el agua, y algunos son hidrof&#237;licos,
lo que significa que atraen el agua. Las secuencias de amino&#225;cidos
que son parte de un dominio transmembrana tienen probabilidad de ser
hidrof&#243;bicas. Sin embargo, la hidrofobicidad no es una caracter&#237;stica
definida con precisi&#243;n, y no existe acuerdo sobre una escala para
medirla.

<P>
Koza et al. 1999[<A
 HREF="algen.html#key-41">41</A>], cap&#237;tulo 16, utilizaron programaci&#243;n
gen&#233;tica para dise&#241;ar un algoritmo que identificase el dominio transmembrana
de una prote&#237;na. Se le suministr&#243; al programa gen&#233;tico un conjunto
de operadores matem&#225;ticos est&#225;ndares con los que trabajar, adem&#225;s
de un conjunto de funciones booleanas para la detecci&#243;n de amino&#225;cidos
que devuelven +1 si el amino&#225;cido de una posici&#243;n dada es el amino&#225;cido
que detectan o -1 en caso contrario. (Por ejemplo, la funci&#243;n A? recibe
como argumento un n&#250;mero que corresponde a una posici&#243;n dentro de
la prote&#237;na, y devuelve +1 si el amino&#225;cido de esa posici&#243;n es alanina,
denotado por la letra A, y si no devuelve -1). Una variable de memoria
compartida conten&#237;a una cuenta de la suma total, y cuando el algoritmo
acababa, el segmento prote&#237;nico se identificaba como dominio transmembrana
si su valor era positivo. Con tan s&#243;lo estas herramientas, &#191;har&#237;a
falta m&#225;s informaci&#243;n para que un dise&#241;ador humano produjese una soluci&#243;n
eficiente a este problema?

<P>
Las aptitudes de las soluciones producidas por la programaci&#243;n gen&#233;tica
fueron evaluadas prob&#225;ndolas con 246 segmentos prote&#237;nicos de los
que se conoc&#237;a su condici&#243;n de transmembrana. Luego se evalu&#243; al mejor
individuo de la prueba con 250 casos adicionales in&#233;ditos (out-of-sample),
y se compar&#243; su efectividad con la de los cuatro mejores algoritmos
humanos para el mismo prop&#243;sito. El resultado: la programaci&#243;n gen&#233;tica
produjo un algoritmo de identificaci&#243;n de segmentos transmembrana
con una tasa total de error del 1,6%-significativamente menor que
las de los cuatro algoritmos humanos, el mejor de los cuales ten&#237;a
una tasa de error del 2,5%. El algoritmo dise&#241;ado gen&#233;ticamente,
al que los autores llamaron regla 0-2-4, funciona de la manera siguiente: 

<P>

<UL>
<LI>Incrementar la suma en 4 unidades por cada instancia de &#225;cido glut&#225;mico
(un amino&#225;cido cargado el&#233;ctricamente y muy hidrof&#237;lico) del segmento
prote&#237;nico.
</LI>
<LI>Incrementar la suma en 0 unidades por cada instancia de alanina, fenilanalina,
isoleucina, leucina, meionina o valina (todos amino&#225;cidos muy hidrof&#243;bicos)
del segmento prote&#237;nico.
</LI>
<LI>Incrementar la suma en 2 unidades por cada instancia de cualquier
otro amino&#225;cido.
</LI>
<LI>Si [(SUMA - 3,1544)/0,9357] es menor que la longitud del segmento
prote&#237;nico, clasificar ese segmento como dominio transmembrana; de
lo contrario, clasificarlo como dominio no transmembrana.
</LI>
</UL>

<P>

<H2><A NAME="SECTION000613000000000000000">
Reconocimiento de patrones y explotaci&#243;n de datos</A>
</H2>

<P>
La competici&#243;n en la industria actual de las telecomunicaciones es
feroz, y se ha acu&#241;ado un nuevo t&#233;rmino -``fuga''<A NAME="tex2html6"
  HREF="#foot204"><SUP><SPAN CLASS="arabic">1</SPAN></SUP></A>- para describir la velocidad a la que los usuarios se cambian de
un proveedor de servicios a otro. La fuga le cuesta a las compa&#241;&#237;as
de telecomunicaciones una gran cantidad de dinero cada a&#241;o, y reducir
las fugas es un factor importante para aumentar la rentabilidad. Si
las compa&#241;&#237;as pueden contactar con los clientes que tienen probabilidad
de cambiar y ofrecerles incentivos especiales para que se queden,
puede reducirse la tasa de fugas; pero ninguna compa&#241;&#237;a tiene los
recursos para contactar a m&#225;s de un peque&#241;o porcentaje de sus clientes.
El problema es, por tanto, c&#243;mo identificar a los clientes que m&#225;s
piensen fugarse con mayor probabilidad. Todas las compa&#241;&#237;as tienen
grandes bases de datos con informaci&#243;n de los clientes que te&#243;ricamente
puede utilizarse para este prop&#243;sito; pero &#191;qu&#233; m&#233;todo funciona mejor
para examinar esta enorme cantidad de datos e identificar los sutiles
patrones y tendencias que indican la probabilidad de fuga de un cliente?

<P>
Au, Chan y Yao 2003[<A
 HREF="algen.html#key-7">7</A>] aplicaron algoritmos gen&#233;ticos a
este problema para generar un conjunto de reglas de tipo si-entonces
para predecir la probabilidad de fuga de distintos grupos de clientes.
En su AG, la primera generaci&#243;n de reglas, todas las cuales ten&#237;an
una condici&#243;n, fue generada utilizando una t&#233;cnica de inducci&#243;n probabil&#237;stica.
Las generaciones posteriores las refinaron, combinando sencillas reglas
de una condici&#243;n con reglas m&#225;s complejas con varias condiciones.
Para la medici&#243;n de la aptitud se utiliz&#243; una medida de correlaci&#243;n
objetiva de la ``interesantitud'', que no necesitaba informaci&#243;n de
entrada subjetiva. El algoritmo evolutivo de explotaci&#243;n de datos
se prob&#243; sobre una base de datos real de 100.000 clientes proporcionada
por una compa&#241;&#237;a malasia, y su rendimiento se compar&#243; con el de dos
m&#233;todos alternativos: una red neuronal multicapa y un algoritmo basado
en &#225;rbol de decisiones ampliamente utilizado, el C4.5. Los autores
afirman que su AE fue capaz de descubrir regularidades ocultas en
la base de datos y ``fue capaz de hacer predicciones precisas de fuga
con distintas tasas de fuga'' (p. 542), superando al C4.5 bajo todas
las circunstancias, superando a la red neuronal en tasas mensuales
de fuga bajas e igual&#225;ndola en tasas de fuga mayores y, en ambos casos,
alcanzando las conclusiones m&#225;s r&#225;pidamente. Algunas ventajas m&#225;s
del enfoque evolutivo son que puede funcionar eficientemente incluso
cuando faltan algunos campos de datos, y que puede expresar sus descubrimientos
en conjuntos de reglas f&#225;cilmente comprensibles, al contrario que
la red neuronal.

<P>
Entre algunas de las reglas m&#225;s interesantes halladas por el AE se
encuentran las siguientes: los clientes tienen m&#225;s probabilidad de
fugarse si se han suscrito personalmente al plan de servicios y no
han sido admitidos en ning&#250;n plan de bonificaci&#243;n (una soluci&#243;n potencial
ser&#237;a admitir a todos esos clientes en planes de bonificaci&#243;n); los
clientes tienen m&#225;s probabilidad de fugarse si viven en Kuala Lumpur,
tienen entre 36 y 44 a&#241;os y pagan sus facturas en efectivo (supuestamente
porque es m&#225;s f&#225;cil cambiarse de proveedor para los clientes que pagan
al contado, a diferencia de los que cargan en cuenta autom&#225;ticamente);
y los clientes que viven en Penang y contrataron a trav&#233;s de un cierto
vendedor tienen m&#225;s probabilidades de fugarse (este vendedor puede
estar proporcionando un mal servicio al cliente y deber&#237;a ser investigado).

<P>
Rizki, Zmuda y Tamburino 2002[<A
 HREF="algen.html#key-53">53</A>] utilizaron algoritmos
evolutivos para evolucionar un complejo sistema de reconocimiento
de patrones con una amplia variedad de usos potenciales. Los autores
se&#241;alan que el reconocimiento de patrones es una tarea cada vez m&#225;s
realizada por algoritmos de aprendizaje autom&#225;tico, en particular,
algoritmos evolutivos. La mayor&#237;a de ellos comienzan con un acervo
de caracter&#237;sticas predefinidas, del que un AE puede seleccionar combinaciones
apropiadas para la tarea en cuesti&#243;n; en contraste, este m&#233;todo empezaba
desde cero, primero evolucionando detectores individuales de caracter&#237;stica
en forma de &#225;rboles de expresiones, y luego evolucionando combinaciones
cooperativas de esos detectores para producir un sistema completo
de reconocimiento de patrones. El proceso evolutivo selecciona autom&#225;ticamente
el n&#250;mero de detectores de caracter&#237;stica, la complejidad de los detectores
y los aspectos espec&#237;ficos de los datos a los que responde cada detector.

<P>
Para probar su sistema, los autores le asignaron la tarea de clasificar
aviones bas&#225;ndose en sus reflexiones r&#225;dar. Un mismo tipo de avi&#243;n
puede devolver se&#241;ales bastante distintas dependiendo del &#225;ngulo y
elevaci&#243;n desde el que se le observa, y distintos tipos de avi&#243;n pueden
devolver se&#241;ales muy parecidas, as&#237; que esto no es una tarea trivial.
El sistema de reconocimiento de patrones evolucionado clasific&#243; correctamente
un 97,2% de los objetivos, un porcentaje neto mayor que el de las
otras tres t&#233;cnicas -una red neuronal perceptr&#243;n, un algoritmo clasificador
KNN y un algoritmo de base radial- con las que fue comparado. (La
precisi&#243;n de la red de base radial era s&#243;lo un 0,5% menor que la
del clasificador evolucionado, una diferencia que no es estad&#237;sticamente
significativa, pero la red de base radial necesit&#243; 256 detectores
de caracter&#237;stica mientras que el sistema reconocedor evolucionado
s&#243;lo utiliz&#243; 17). Como afirman los autores, ``los sistemas de reconocimiento
que evolucionan utilizan menos caracter&#237;sticas que los sistemas producidos
utilizando t&#233;cnicas convencionales, pero consiguen una precisi&#243;n de
reconocimiento comparable o superior'' (p. 607). Tambi&#233;n se han aplicado
varios aspectos de su sistema en problemas que incluyen el reconocimiento
&#243;ptico de caracteres, la revisi&#243;n industrial y el an&#225;lisis m&#233;dico
de im&#225;genes.

<P>
Hughes y Leyland 2000[<A
 HREF="algen.html#key-37">37</A>] tambi&#233;n aplicaron AGs multiobjetivo
a la tarea de clasificar objetivos bas&#225;ndose en sus reflexiones r&#225;dar.
Los datos de una secci&#243;n transversal r&#225;dar de alta resoluci&#243;n necesitan
enormes cantidades de espacio de almacenamiento en disco, y producir
un modelo realista de la fuente a partir de los datos es muy costoso
computacionalmente. En contraste, el m&#233;todo basado en el AG de los
autores demostr&#243; ser muy exitoso, produciendo un modelo tan bueno
como el del m&#233;todo iterativo tradicional, pero reduciendo el gasto
computacional y las necesidades de almacenamiento hasta el punto de
que era factible generar buenos modelos en un ordenador de escritorio.
En contraste, el m&#233;todo iterativo tradicional requiere diez veces
m&#225;s resoluci&#243;n y 560.000 veces m&#225;s accesos a los datos de imagen para
producir modelos de calidad similar. Los autores concluyen que sus
resultados ``demuestran claramente'' (p. 160) la capacidad del AG
de procesar datos de r&#225;dar bidimensionales y tridimensionales de cualquier
nivel de resoluci&#243;n con muchos menos c&#225;lculos que los m&#233;todos tradicionales,
manteniendo una precisi&#243;n aceptablemente alta.

<P>

<H2><A NAME="SECTION000614000000000000000">
Rob&#243;tica</A>
</H2>

<P>
El torneo internacional <a href="http://www.robocup.org">RoboCup</a> es un
proyecto para promocionar el avance de la rob&#243;tica, la inteligencia
artificial y los campos relacionados, proporcionando un problema est&#225;ndar
con el que probar las nuevas tecnolog&#237;as -concretamente, es un campeonato
anual de f&#250;tbol entre equipos de robots aut&#243;nomos. (El objetivo fijado
es desarrollar un equipo de robots humanoides que puedan vencer al
equipo humano de f&#250;tbol que sea campe&#243;n del mundo en 2050; actualmente,
la mayor&#237;a de los equipos de robots participantes funcionan con ruedas).
Los programas que controlan a los miembros del equipo rob&#243;tico deben
exhibir un comportamiento complejo, decidiendo cu&#225;ndo bloquear, cu&#225;ndo
tirar, c&#243;mo moverse, cu&#225;ndo pasar la pelota a un compa&#241;ero, c&#243;mo coordinar
la defensa y el ataque, etc&#233;tera. En la liga simulada de 1997, David
Andre y Astro Teller inscribieron a un equipo llamado Darwin United
cuyos programas de control hab&#237;an sido desarrollados autom&#225;ticamente
desde cero mediante programaci&#243;n gen&#233;tica, un desaf&#237;o a la creencia
convencional de que ``este problema es simplemente demasiado dif&#237;cil
para una t&#233;cnica como &#233;sa'' (Andre y Teller 1999[<A
 HREF="algen.html#key-3">3</A>], p.
346).

<P>
Para resolver este dif&#237;cil problema, Andre y Teller le proporcionaron
al programa gen&#233;tico un conjunto de funciones de control primitivas
como girar, moverse, tirar, etc&#233;tera. (Estas funciones estaban tambi&#233;n
sujetas al cambio y refinamiento durante el curso de la evoluci&#243;n).
Su funci&#243;n de aptitud, escrita para que recompensara el buen juego
en general en lugar de marcar goles expresamente, proporcionaba una
lista de objetivos cada vez m&#225;s importantes: acercarse a la pelota,
golpear la pelota, conservar la pelota en el campo contrario, moverse
en la direcci&#243;n correcta, marcar goles y ganar el partido. Debe se&#241;alarse
que no se suministr&#243; ning&#250;n c&#243;digo para ense&#241;ar espec&#237;ficamente al
equipo c&#243;mo conseguir estos objetivos complejos. Luego los programas
evolucionados se evaluaron utilizando un modelo de selecci&#243;n jer&#225;rquico:
en primer lugar, los equipos candidatos se probaron en un campo vac&#237;o
y, si no marcaban un gol en menos de 30 segundos, se rechazaban. Luego
se evaluaron haci&#233;ndoles jugar contra un equipo estacionario de ``postes
pateadores'' que golpeaban la pelota hacia el campo contrario. En
tercer lugar, el equipo jugaba un partido contra el equipo ganador
de la competici&#243;n RoboCup de 1997. Finalmente, los equipos que marcaron
al menos un gol contra este equipo jugaron unos contra otros para
determinar cu&#225;l era el mejor.

<P>
De los 34 equipos de su divisi&#243;n, Darwin United acab&#243; en decimos&#233;ptima
posici&#243;n, situ&#225;ndose justo en el medio de la clasificaci&#243;n y superando
a la mitad de los participantes escritos por humanos. Aunque una victoria
en el torneo sin duda habr&#237;a sido m&#225;s impresionante, este resultado
es competitivo y significante de pleno derecho, y lo parece a&#250;n m&#225;s
a la luz de la historia. Hace unos 25 a&#241;os, los programas inform&#225;ticos
que jugaban al ajedrez estaban en su infancia; por primera vez, una
computadora hab&#237;a sido inscrita recientemente en una competici&#243;n regional,
aunque no gan&#243; (Sagan 1979[<A
 HREF="algen.html#key-55">55</A>], p. 286). Pero ``una m&#225;quina
que juega al ajedrez a un nivel medio de la capacidad humana es una
m&#225;quina muy capaz'' (ibid.), y podr&#237;a decirse que lo mismo es cierto
para el f&#250;tbol robotizado. Si las m&#225;quinas de ajedrez actuales compiten
al nivel de los grandes maestros, &#191;qu&#233; tipo de sistemas producir&#225;
la programaci&#243;n gen&#233;tica dentro de 20 o 30 a&#241;os?

<P>

<H2><A NAME="SECTION000615000000000000000">
Dise&#241;o de rutas y horarios</A>
</H2>

<P>
Burke y Newall 1999[<A
 HREF="algen.html#key-11">11</A>] utilizaron algoritmos gen&#233;ticos
para dise&#241;ar los horarios de los ex&#225;menes universitarios. Se sabe
que, en general, el problema del horario es NP-completo, lo que significa
que no se conoce un m&#233;todo para hallar con garant&#237;as una soluci&#243;n
&#243;ptima en un tiempo razonable. En un problema as&#237;, hay restricciones
duras -no puede asignarse el mismo aula a dos ex&#225;menes a la vez-
y restricciones suaves -si es posible, no deben asignarse varios
ex&#225;menes en sucesi&#243;n a un mismo estudiante, para minimizar la fatiga.
Las restricciones duras deben satisfacerse, mientras que las restricciones
suaves deben satisfacerse lo m&#225;ximo posible. Los autores llaman ``algoritmo
mem&#233;tico'' a su m&#233;todo h&#237;brido para resolver este problema: un algoritmo
evolutivo con selecci&#243;n por rango proporcional a la aptitud, combinado
con un trepacolinas local para optimizar las soluciones halladas por
el AE. El AE se utiliz&#243; en cuatro conjuntos de datos de universidades
reales (la menor de las cuales ten&#237;a 25.000 alumnos), y sus resultados
se compararon con los resultados producidos por un m&#233;todo heur&#237;stico
de vuelta atr&#225;s, un algoritmo muy consolidado que se encuentra entre
los mejores que se conocen para este problema y que se utiliza en
varias universidades. Comparado con este m&#233;todo, el AE produjo un
resultado con una reducci&#243;n de la penalizaci&#243;n bastante uniforme del
40%.

<P>
He y Mort 2000[<A
 HREF="algen.html#key-35">35</A>] aplicaron algoritmos gen&#233;ticos al problema
de hallar rutas &#243;ptimas en las redes de telecomunicaciones (como las
redes de telefon&#237;a e Internet), que se usan para transmitir datos
desde los remitentes hasta los destinatarios. Esto es un problema
NP-dif&#237;cil, un tipo de problema para el que los AGs son ``extremadamente
aptos... y han encontrado una enorme variedad de aplicaciones
exitosas en esos campos'' (p. 42). Es adem&#225;s un problema multiobjetivo,
en el que hay que equilibrar objetivos en conflicto como maximizar
el caudal de datos, minimizar los retrasos en la transmisi&#243;n y la
p&#233;rdida de datos, encontrar caminos de bajo coste y distribu&#237;r la
carga uniformemente entre los encaminadores o conmutadores de la red.
Cualquier algoritmo real satisfactorio debe tambi&#233;n ser capaz de redirigir
el tr&#225;fico de las rutas principales que fallen o est&#233;n congestionadas.

<P>
En el AG h&#237;brido de los autores se utiliz&#243; un algoritmo de tipo ``primero
el camino m&#225;s corto'', que minimiza el n&#250;mero de ``saltos'' que debe
realizar un paquete de datos dado, para generar la semilla de la poblaci&#243;n
inicial. Sin embargo, esta soluci&#243;n no tiene en cuenta la congesti&#243;n
o fallo de los enlaces, condiciones inevitables en redes reales, y
es entonces cuando el AG toma el control, intercambiando secciones
de rutas. Cuando se prob&#243; sobre un conjunto de datos derivado de una
base de datos en red real de Oracle, se descubri&#243; que el AG era capaz
de redirigir enlaces rotos o congestionados, equilibrar la carga de
tr&#225;fico y maximizar el caudal total de la red. Los autores afirman
que estos resultados demuestran la ``efectividad y escalabilidad''
del AG y que ``se pueden conseguir soluciones &#243;ptimas o casi &#243;ptimas''
(p. 49).

<P>
Esta t&#233;cnica ha encontrado aplicaciones reales para prop&#243;sitos similares,
como informan Begley y Beals 1995[<A
 HREF="algen.html#key-9">9</A>]. La compa&#241;&#237;a de telecomunicaciones
U.S. West (ahora fusionada con Qwest) se enfrent&#243; a la tarea de desplegar
una red de fibra &#243;ptica. Hasta hace poco, el problema de dise&#241;ar la
red para minimizar la longitud total de cable desplegado era resuelto
por un ingeniero experimentado; ahora la compa&#241;&#237;a utiliza un algoritmo
gen&#233;tico para realizar la tarea autom&#225;ticamente. Los resultados: ``El
tiempo de dise&#241;o para las redes nuevas ha ca&#237;do de dos meses a dos
d&#237;as, y le supone un ahorro a U.S. West de 1 mill&#243;n a 10 millones
de d&#243;lares cada una'' (p. 70).

<P>
Jensen 2003[<A
 HREF="algen.html#key-38">38</A>] y Chryssolouris y Subramaniam 2001[<A
 HREF="algen.html#key-16">16</A>]
aplicaron algoritmos gen&#233;ticos a la tarea de generar programas para
l&#237;neas de montaje (job shop scheduling). &#201;ste es un problema de optimizaci&#243;n
NP-dif&#237;cil con m&#250;ltiples criterios: deben tomarse en cuenta factores
como el coste, los retrasos y el rendimiento, y puede que se tenga
que cambiar al vuelo el programa de la l&#237;nea de montaje debido a aver&#237;as
en la maquinaria, ausencia de empleados, retrasos en la entrega de
piezas, y otras complicaciones, lo que hace que la robustez del programa
sea una consideraci&#243;n importante. Ambos art&#237;culos concluyen que los
AGs son significativamente superiores a las reglas de despacho de
prioridad utilizadas com&#250;nmente, al producir programas eficientes
que pueden tratar con m&#225;s facilidad los retrasos y las aver&#237;as. Estos
resultados no son simplemente te&#243;ricos, sino que se han aplicado a
situaciones reales:

<P>
Como informa Naik 1996[<A
 HREF="algen.html#key-48">48</A>], los organizadores de los Juegos
Paraol&#237;mpicos de 1992 utilizaron un AG para dise&#241;ar los horarios de
los eventos. Como informa Petzinger 1995[<A
 HREF="algen.html#key-50">50</A>], John Deere
&amp; Co. ha utilizado AGs para generar los programas de montaje
para una planta de Moline, Illinois, que fabrica plantadoras y otras
maquinarias agr&#237;colas pesadas. Al igual que los coches de lujo, &#233;stas
pueden constru&#237;rse en una gran variedad de configuraciones con muchas
partes y opciones distintas, y la enorme cantidad de maneras posibles
de construirlas implica que el dise&#241;o eficiente de programas de montaje
sea un problema aparentemente intratable. La productividad se ve&#237;a
mermada por cuellos de botella en el montaje, los equipos de trabajadores
discut&#237;an, y se estaba perdiendo dinero. Finalmente, en 1993, Deer
acudi&#243; a Bill Fulkerson, un analista e ingeniero de personal que concibi&#243;
la utilizaci&#243;n de un algoritmo gen&#233;tico para producir programas de
montaje para la planta. Tras superar el escepticismo inicial, el AG
demostr&#243; su val&#237;a r&#225;pidamente: la producci&#243;n mensual aument&#243; un 50
por ciento, el tiempo extra casi desapareci&#243; y otras plantas de Deere
est&#225;n incorporando los AGs en sus propios dise&#241;os de programas de
montaje. 

<P>
Como informa Rao 1998[<A
 HREF="algen.html#key-52">52</A>], Volvo ha utilizado un programa
evolutivo llamado OptiFlex para dise&#241;ar el programa de montaje de
su f&#225;brica de Dubl&#237;n, Virginia, de un mill&#243;n de metros cuadrados,
una tarea que requiere controlar cientos de restricciones y millones
de permutaciones posibles para cada veh&#237;culo. Como todos los algoritmos
gen&#233;ticos, OptiFlex funciona combinando aleatoriamente distintos programas
de montaje posibles, determinando su aptitud clasific&#225;ndolos en base
a sus costos, beneficios y restricciones, y luego haciendo que las
mejores soluciones intercambien genes entre ellas y vuelvan a la poblaci&#243;n
para otra prueba. Hasta hace poco, esta desalentadora tarea era responsabilidad
de un ingeniero humano, al que le llevaba hasta cuatro d&#237;as producir
el programa para cada semana; ahora, gracias a los AGs, esta tarea
se puede completar en un d&#237;a con una m&#237;nima intervenci&#243;n humana.

<P>
Como informa Lemley 2001[<A
 HREF="algen.html#key-45">45</A>], United Distillers and Vintners,
una empresa escocesa que es el mayor y m&#225;s rentable distribuidor de
licores del mundo y es responsable de m&#225;s de un tercio de la producci&#243;n
mundial de whisky de grano, utiliza un algoritmo gen&#233;tico para administrar
su inventario y sus suministros. Esto es una tarea desalentadora que
exige almacenar y distribu&#237;r eficientemente m&#225;s de 7 millones de barriles,
que contienen 60 recetas distintas, entre un enorme sistema de almacenes
y destiler&#237;as, dependiendo de una multitud de factores como la edad,
el n&#250;mero de malta, el tipo de madera y las condiciones del mercado.
Anteriormente, coordinar este complejo flujo de suministro y demanda
requer&#237;a de cinco empleados a tiempo completo. Hoy, unas cuantas pulsaciones
de teclado en un ordenador solicitan a un algoritmo gen&#233;tico que genere
un programa cada semana, y la eficiencia de almacenamiento casi se
ha duplicado.

<P>
Beasley, Sonander y Havelock 2001[<A
 HREF="algen.html#key-8">8</A>] utilizaron un AG para
programar los aterrizajes del London Heathrow, el aeropuerto m&#225;s transitado
del Reino Unido. Esto es un problema multiobjetivo que implica, entre
otras cosas, minimizar los retrasos y maximizar el n&#250;mero de vuelos
mientras se mantiene la suficiente distancia de separaci&#243;n entre los
aviones (los v&#243;rtices de aire que se forman en la estela de un avi&#243;n
pueden ser peligrosos para otro avi&#243;n que vuele demasiado cerca).
Comparado con los horarios reales de un periodo intensivo del aeropuerto,
el AG fue capaz de reducir el tiempo de espera medio en un 2-5%,
implicando dos o tres vuelos extra despegando y aterrizando por cada
hora -una mejora significativa. Sin embargo, se han logrado mejoras
mayores: como se informa en Wired 2002[<A
 HREF="algen.html#key-1">1</A>], aeropuertos internacionales
y l&#237;neas a&#233;reas importantes como Heatrhow, Toronto, Sydney, Las Vegas,
San Francisco, America West Airlines, AeroMexico y Delta Airlines
est&#225;n utilizando algoritmos gen&#233;ticos para programar los despegues,
aterrizajes, mantenimiento y otras tareas, mediante el software del
Ascent Technology's SmartAirport Operations Center (ver <a href="http://www.ascent.com/faq.html">
http://www.ascent.com/faq.html</a>).
Cruzando y mutando las soluciones en forma de horarios que incorporan
miles de variables, ``Ascent vence con comodidad a los humanos, aumentando
la productividad hasta en un 30 por ciento en todos los aeropuertos
en los que se ha implementado''.

<P>

<H2><A NAME="SECTION000616000000000000000">
Ingenier&#237;a de sistemas</A>
</H2>

<P>
Benini y Toffolo 2002[<A
 HREF="algen.html#key-10">10</A>] aplicaron un algoritmo gen&#233;tico
a la tarea multiobjetivo de dise&#241;ar molinos e&#243;licos para generar energ&#237;a
el&#233;ctrica. Este dise&#241;o ``es un procedimiento complejo caracterizado
por varias decisiones sobre contrapartidas... El proceso de
toma de decisiones es muy dif&#237;cil y no hay tendencias de dise&#241;o bien
establecidas'' (p. 357); como resultado, hoy existen varios tipos
de turbina distintos y no hay acuerdo sobre cu&#225;l es la &#243;ptima, si
alguna lo es. Deben tomarse en cuenta objetivos mutuamente exclusivos
como la producci&#243;n m&#225;xima de energ&#237;a anual y el coste m&#237;nimo de la
energ&#237;a. En este art&#237;culo se utiliz&#243; un algoritmo evolutivo multiobjetivo
para encontrar el mejor conjunto de contrapartidas entre estos objetivos,
construyendo palas de molino con una configuraci&#243;n &#243;ptima de caracter&#237;sticas
como la velocidad de la punta de la pala, la raz&#243;n buje/punta, y la
distribuci&#243;n de cuerda y giro. Al final, al AG consigui&#243; encontrar
soluciones competitivas con los dise&#241;os comerciales, adem&#225;s de dilucidar
m&#225;s claramente los m&#225;rgenes entre los que se puede aumentar la producci&#243;n
anual de energ&#237;a sin producir dise&#241;os demasiado caros.

<P>
Haas, Burnham y Mills 1997[<A
 HREF="algen.html#key-32">32</A>] utilizaron un algoritmo gen&#233;tico
multiobjetivo para optimizar la forma, orientaci&#243;n e intensidad del
haz de los emisores de rayos X utilizados en la radioterapia dirigida,
para destru&#237;r los tumores cancerosos al tiempo que se evita el tejido
sano. (Los fotones de rayos X dirigidos hacia un tumor tienden a dispersarse
por las estructuras interiores del cuerpo, da&#241;ando inintencionadamente
los &#243;rganos internos. El reto consiste en minimizar este efecto mientras
se maximiza la dosis de radiaci&#243;n dirigida hacia el tumor). Utilizando
un modelo de aptitud basada en rango, los investigadores comenzaron
con la soluci&#243;n producida por el m&#233;todo convencional, un m&#233;todo de
m&#237;nimos cuadrados iterativo, y luego utilizaron el AG para modificarlo
y mejorarlo. Construyendo un modelo del cuerpo humano y exponi&#233;ndolo
al rayo evolucionado por el AG, encontraron un buen acuerdo entre
las distribuciones de radiaci&#243;n predichas y reales. Los autores concluyen
que sus resultados ``muestran una protecci&#243;n [de los &#243;rganos sanos]
que no pod&#237;a lograrse utilizando las t&#233;cnicas convencionales'' (p.
1745).

<P>
Lee y Zak 2002[<A
 HREF="algen.html#key-44">44</A>] utilizaron un algoritmo gen&#233;tico para
evolucionar un conjunto de reglas para controlar un sistema de frenos
antibloqueo automovil&#237;stico. Aunque la capacidad que tienen los sistemas
de freno antibloqueo de reducir la distancia de frenada y mejorar
la maniobrabilidad ha salvado muchas vidas, el rendimiento del ABS
depende de las condiciones de la superficie de la carretera: por ejemplo,
un controlador ABS que est&#233; optimizado para el asfalto seco no funcionar&#225;
igual de bien en carreteras mojadas o heladas, y viceversa. En este
art&#237;culo, los autores proponen un AG para ajustar un controlador ABS
que pueda identificar las propiedades de la superficie de la carretera
(monitorizando el patinaje y aceleraci&#243;n de las ruedas) y pueda actuar
en consecuencia, liberando la cantidad adecuada de fuerza de frenado
para maximizar la tracci&#243;n de las ruedas. En las pruebas, el ABS puesto
a punto gen&#233;ticamente ``exhibe caracter&#237;sticas de rodada excelentes''
(p. 206) y fue ``muy superior'' (p. 209) a los otros dos m&#233;todos de
maniobras de frenado, encontrando con rapidez nuevos valores &#243;ptimos
para el patinaje de las ruedas cuando cambia el tipo de terreno bajo
un coche en movimiento, y reduciendo la distancia total de frenada.
``La lecci&#243;n que hemos aprendido de nuestro experimento... es
que un AG puede ayudar a ajustar incluso un controlador bien dise&#241;ado.
En nuestro caso, ya ten&#237;amos una buena soluci&#243;n del problema; sin
embargo, con la ayuda de un AG, conseguimos mejorar significativamente
la estrategia de control. En resumen, parece que merece la pena intentar
aplicar un AG incluso en un controlador bien dise&#241;ado, porque hay
muchas probabilidades de que se pueda hallar una configuraci&#243;n del
controlador mejor utilizando AGs'' (p. 211).

<P>
Como cita Schechter 2000[<A
 HREF="algen.html#key-59">59</A>], el Dr. Peter Senecal, de la
Universidad de Wisconsin, utiliz&#243; algoritmos gen&#233;ticos de poblaci&#243;n
peque&#241;a para mejorar la eficiencia de los motores di&#233;sel. Estos motores
funcionan inyectando combustible en una c&#225;mara de combusti&#243;n que est&#225;
llena de aire extremadamente comprimido, y por tanto extremadamente
caliente, lo bastante caliente para hacer que el combustible explote
y empuje un pist&#243;n que produce la fuerza motriz del veh&#237;culo. Este
dise&#241;o b&#225;sico ha cambiado poco desde que Rudolf Diesel lo invent&#243;
en 1893; aunque se ha empleado mucho esfuerzo en realizar mejoras,
es una tarea muy dif&#237;cil de realizar anal&#237;ticamente, porque requiere
un conocimiento preciso del comportamiento turbulento que exhibe la
mezcla de combustible y aire, y de la variaci&#243;n simult&#225;nea de muchos
par&#225;metros independientes. Sin embargo, el m&#233;todo de Senecal prescind&#237;a
de ese conocimiento espec&#237;fico del problema y, en cambio, funcionaba
evolucionando par&#225;metros como la presi&#243;n de la c&#225;mara de combusti&#243;n,
los tiempos de inyecci&#243;n de combustible y la cantidad de combustible
de cada inyecci&#243;n. El resultado: la simulaci&#243;n produjo un motor mejorado
que consum&#237;a un 15% menos de combustible que un motor diesel normal
y produc&#237;a dos tercios menos de &#243;xido n&#237;trico de escape y la mitad
de holl&#237;n. Luego el equipo de Senecal construy&#243; un motor di&#233;sel real
de acuerdo con las especificaciones de la soluci&#243;n evolucionada, y
obtuvieron los mismos resultados. Ahora Senecal sigue su trabajo evolucionando
la geometr&#237;a del propio motor, lo que con suerte producir&#225; todav&#237;a
m&#225;s mejoras.

<P>
Como citan Begley y Beals 1995[<A
 HREF="algen.html#key-9">9</A>], Texas Instruments utiliz&#243;
un algoritmo gen&#233;tico para optimizar la disposici&#243;n de los componentes
de un chip inform&#225;tico, colocando las estructuras de manera que se
minimice el &#225;rea total para crear un chip lo m&#225;s peque&#241;o posible.
Utilizando una estrategia de conexiones que no se le hab&#237;a ocurrido
a ning&#250;n humano, el AG alcanz&#243; un dise&#241;o que ocupaba un 18% menos
de espacio.

<P>
Finalmente, como cita Ashley 1992[<A
 HREF="algen.html#key-5">5</A>], empresas de la industria
aeroespacial, automovil&#237;stica, fabril, turbomaquinaria y electr&#243;nica
est&#225;n utilizando un sistema de software propietario conocido como
Engineous, que utiliza algoritmos gen&#233;ticos, para dise&#241;ar y mejorar
motores, turbinas y otros dispositivos industriales. En palabras de
su creador, el Dr. Siu Shing Tong, Engineous es ``un maestro `toqueteador',
ensayando incansablemente las puntuaciones de escenarios de tipo ``y-si''
hasta que emerge la mejor soluci&#243;n posible'' (p. 49). En un ensayo
del sistema, Engineous consigui&#243; producir un incremento del 0,92 por
ciento de la eficiencia de una turbina experimental en s&#243;lo una semana,
mientras que diez semanas de trabajo de un dise&#241;ador humano s&#243;lo produjeron
un 0,5 por ciento de mejora.

<P>
Supuestamente, Engineous no s&#243;lo cuenta con algoritmos gen&#233;ticos;
tambi&#233;n emplea t&#233;cnicas de optimizaci&#243;n num&#233;rica y sistemas expertos
que utilizan reglas si-entonces para imitar el proceso de toma de
decisiones de un ingeniero humano. Sin embargo, estas t&#233;cnicas dependen
mucho de informaci&#243;n espec&#237;fica del dominio, carecen de aplicabilidad
general, y son propensas a quedar atrapadas en &#243;ptimos locales. En
contraste, el uso de algoritmos gen&#233;ticos permite a Engineous explorar
regiones del espacio de b&#250;squeda que pasan por alto los otros m&#233;todos.

<P>
Engineous ha obtenido un amplio uso en una gran variedad de industrias
y problemas. El m&#225;s famoso fue cuando se utiliz&#243; para mejorar la turbina
generadora de energ&#237;a del avi&#243;n Boeing 777; como informan Begley y
Beals 1995[<A
 HREF="algen.html#key-9">9</A>], el dise&#241;o optimizado gen&#233;ticamente era casi
un 1% m&#225;s eficiente en combustible que los motores anteriores, lo
que en un campo como &#233;ste es una ganancia ca&#237;da del cielo. Engineous
tambi&#233;n se ha utilizado para optimizar la configuraci&#243;n de motores
el&#233;ctricos industriales, generadores hidroel&#233;ctricos y turbinas de
vapor, para proyectar redes el&#233;ctricas, y para dise&#241;ar generadores
superconductores y generadores de energ&#237;a nuclear para sat&#233;lites en
&#243;rbita. Rao 1998[<A
 HREF="algen.html#key-52">52</A>] informa tambi&#233;n de que la NASA ha utilizado
Engineous para optimizar el dise&#241;o de un avi&#243;n de gran altitud para
analizar la disminuci&#243;n del ozono, que debe ser a la vez ligero y
eficiente.

<P>

<H1><A NAME="SECTION00070000000000000000">
Argumentos creacionistas</A>
</H1>

<P>
Como era de esperar, la demostraci&#243;n real del poder de la evoluci&#243;n
que representan los AGs ha resultado sorprendente y descorcentante
para los creacionistas, que siempre han afirmado que s&#243;lo un dise&#241;o
inteligente, no la variaci&#243;n aleatoria y la selecci&#243;n, puede haber
producido la cantidad y complejidad de informaci&#243;n que contienen los
seres vivos. Por tanto, han argumentado que el &#233;xito de los algoritmos
gen&#233;ticos no nos permite deducir nada sobre la evoluci&#243;n biol&#243;gica.
Abordar&#233; las cr&#237;ticas de dos antievolucionistas que representan dos
puntos de vista distintos: un creacionista de tipo tierra-joven, el
Dr. Don Batten, de ``Answers in Genesis'', que ha escrito un art&#237;culo
titulado ``<a href="http://www.answersingenesis.org/home/area/faq/docs/genetic_algorithm.asp">Algoritmos gen&#233;ticos - &#191;demuestran que la evoluci&#243;n funciona?</a>'',
y un creacionista de tipo tierra-vieja y defensor del dise&#241;o inteligente,
el Dr. William Dembski, cuyo reciente libro ``No Free Lunch'' (Dembski
2002[<A
 HREF="algen.html#key-21">21</A>]) trata sobre este tema.

<P>

<H2><A NAME="SECTION00071000000000000000">
Don Batten</A>
</H2>

<P>

<H3><A NAME="SECTION00071100000000000000">
Algunos caracteres de los seres vivos son cualitativos, mientras
que los AGs son siempre cuantitativos</A>
</H3>

<P>
Batten afirma que los AGs deben ser cuantitativos, de manera que se
pueda seleccionar cualquier mejora. Esto es cierto. Luego continua
diciendo: ``Muchos caracteres biol&#243;gicos son cualitativos -o funcionan
o no funcionan, as&#237; que no existe una manera de llegar paso a paso
de la ausencia de funci&#243;n a la funci&#243;n''. Sin embargo, esta aseveraci&#243;n
no ha sido demostrada, y no est&#225; apoyada por la evidencia. Batten
ni siquiera intenta ofrecer un ejemplo de caracter biol&#243;gico que ``o
funciona o no funciona'', y por tanto no pueda construirse paso a
paso.

<P>
Pero aunque hubiera ofrecido tal ejemplo de caracter, &#191;c&#243;mo podr&#237;a
demostrar razonablemente que no hay un camino paso a paso hasta &#233;l?
Aunque no conozcamos tal camino, &#191;significa eso que no existe ninguno?
Por supuesto que no. Batten afirma efectivamente que si no entendemos
c&#243;mo han evolucionado ciertos caracteres, entonces es imposible que
esos caracteres hayan evolucionado -un ejemplo cl&#225;sico de la falacia
l&#243;gica elemental del argumento de la ignorancia. El espacio de b&#250;squeda
de todas las posibles variantes de cualquier caracter biol&#243;gico dado
es enorme, y en la mayor&#237;a de los casos nuestro conocimiento supone
tan s&#243;lo una fracci&#243;n infinitesimal de todas las posibilidades. Perfectamente
pueden existir numerosos caminos hacia una estructura de los que no
conozcamos nada todav&#237;a; no hay ninguna raz&#243;n en absoluto para creer
que nuestra ignorancia actual establece l&#237;mites a nuestro progreso
futuro. De hecho, la historia nos da razones para estar seguros de
esto: los cient&#237;ficos han hecho enormes progresos para explicar la
evoluci&#243;n de muchas estructuras y sistemas biol&#243;gicos complejos, tanto
macrosc&#243;picos como microsc&#243;picos (por ejemplo, vea estas p&#225;ginas sobre
la <a href="http://www.talkorigins.org/origins/postmonth/jan04.html#run">
evoluci&#243;n de sistemas moleculares complejos</a>,
<a href="http://www.talkorigins.org/origins/postmonth/apr01.html">genes ``reloj''</a>,
<a href="http://www.talkorigins.org/faqs/woodpecker/woodpecker.html">la lengua del
p&#225;jaro carpintero</a>
o el <a href="http://www.talkorigins.org/faqs/bombardier.html">escarabajo bombardero</a>).
Tenemos justificaci&#243;n para creer probable que los que nos han eludido
hasta ahora tambi&#233;n se entender&#225;n con claridad en el futuro. 

<P>
De hecho, los propios AGs nos ofrecen una excelente raz&#243;n para suponer
esto. Muchos de los problemas en los que se han aplicado son problemas
complejos de ingenier&#237;a y dise&#241;o de los que no se conoc&#237;a la soluci&#243;n
previamente, y por lo tanto el problema no pod&#237;a ``ama&#241;arse'' para
facilitar el &#233;xito del algoritmo. Si los creacionistas tuvieran raz&#243;n,
habr&#237;a sido completamente razonable esperar que los algoritmos gen&#233;ticos
hubieran fallado estrepitosamente una y otra vez al ser aplicados
a estos problemas, pero, en cambio, ha ocurrido justo lo contrario:
los AGs han descubierto soluciones poderosas y de gran calidad a problemas
dif&#237;ciles en una gran variedad de campos. Esto pone seriamente en
duda incluso si existen problemas como los que Batten describe, cuyas
soluciones sean inaccesibles a un proceso evolutivo.

<P>

<H3><A NAME="SECTION00071200000000000000">
Los AGs seleccionan un caracter cada vez, mientras que los seres
vivos son multidimensionales</A>
</H3>

<P>
Batten afirma que, en los AGs, ``se selecciona un caracter individual,
mientras que cualquier ser vivo es multidimensional'', y afirma que
en los seres vivos con cientos de caracteres, ``la selecci&#243;n tiene
que operar con todos los caracteres que afecten a la supervivencia'',
mientras que ``[un] AG no funciona con tres o cuatro objetivos
diferentes, o me atrever&#237;a a decir que ni siquiera con dos''. 

<P>
Este argumento revela la profunda ignorancia de Batten sobre la literatura
relevante. Tan s&#243;lo un vistazo superficial del trabajo realizado con
algoritmos evolutivos (o un vistazo a la secci&#243;n anterior de este
ensayo) habr&#237;a revelado que los algoritmos gen&#233;ticos multiobjetivo
son un campo de investigaci&#243;n importante y floreciente dentro del
m&#225;s amplio campo de la computaci&#243;n evolutiva, y le habr&#237;a evitado
realizar una afirmaci&#243;n tan embarazosamente incorecta. Existen art&#237;culos
de revista, n&#250;meros enteros de revistas prominentes sobre computaci&#243;n
evolutiva, conferencias enteras y libros enteros sobre el tema de
los AGs multiobjetivo. Coello 2000[<A
 HREF="algen.html#key-18">18</A>] proporciona una recopilaci&#243;n
muy extensa, con cinco p&#225;ginas de referencias a art&#237;culos sobre el
uso de algoritmos gen&#233;ticos multiobjetivo en una amplio abanico de
campos; vea tambi&#233;n Fleming y Purshouse 2002[<A
 HREF="algen.html#key-22">22</A>]; Hanne
2000[<A
 HREF="algen.html#key-33">33</A>]; Zitzler y Thiele 1999[<A
 HREF="algen.html#key-65">65</A>]; Fonseca y
Fleming 1995[<A
 HREF="algen.html#key-23">23</A>]; Srinivas y Deb 1994[<A
 HREF="algen.html#key-60">60</A>]; Goldberg
1989[<A
 HREF="algen.html#key-29">29</A>], p. 197. Sobre el uso de AGs multiobjetivo para
resolver problemas espec&#237;ficos, vea los libros y art&#237;culos: Obayashi
et al. 2000[<A
 HREF="algen.html#key-49">49</A>]; Sasaki et al. 2001[<A
 HREF="algen.html#key-57">57</A>]; Benini
y Toffolo 2002[<A
 HREF="algen.html#key-10">10</A>]; Haas, Burnham y Mulls 1997[<A
 HREF="algen.html#key-32">32</A>];
Chryssolouris y Subramaniam 2001[<A
 HREF="algen.html#key-16">16</A>]; Hughes y Leyland 2000[<A
 HREF="algen.html#key-37">37</A>];
He y Mort 2000[<A
 HREF="algen.html#key-35">35</A>]; Kewley y Embrechts 2002[<A
 HREF="algen.html#key-39">39</A>];
Beasley, Sonander y Havelock 2001[<A
 HREF="algen.html#key-8">8</A>]; Sato et al. 2002[<A
 HREF="algen.html#key-58">58</A>];
Tang et al. 1996[<A
 HREF="algen.html#key-62">62</A>]; Williams, Crossley y Lang 2001[<A
 HREF="algen.html#key-64">64</A>];
Koza et al. 1999[<A
 HREF="algen.html#key-41">41</A>]; Koza et al. 2003[<A
 HREF="algen.html#key-42">42</A>]. Vea
un repositorio extenso de referencias sobre AGs multiobjetivo en <a href="http://www.lania.mx/ccoello/EMOO">
http://www.lania.mx/ccoello/EMOO</a>.

<P>

<H3><A NAME="SECTION00071300000000000000">
Los AGs no permiten la posibilidad de una extinci&#243;n o una cat&#225;strofe
de errores</A>
</H3>

<P>
Batten afirma que, en los AGs, ``siempre sobrevive algo para mantener
el proceso'', mientras que esto no es necesariamente cierto en el
mundo real -en resument, los AGs no permiten la posibilidad de una
extinci&#243;n. 

<P>
Sin embargo, esto no es cierto; la extinci&#243;n puede ocurrir. Por ejemplo,
algunos AGs utilizan un modelo de selecci&#243;n con umbral en el que los
individuos deben tener una aptitud superior a un nivel predeterminado
para poder sobrevivir y reproducirse (Haupt y Haupt 1998[<A
 HREF="algen.html#key-34">34</A>],
p. 37). Si no hay ning&#250;n individuo que cumpla este criterio en este
tipo de AG, la poblaci&#243;n puede extinguirse efectivamente. Pero incluso
en AGs que no establecen umbrales pueden ocurrir estados an&#225;logos
a la extinci&#243;n. Si las tasas de mutaci&#243;n son demasiado altas o las
presiones selectivas demasiado fuertes, un AG nunca encontrar&#225; una
soluci&#243;n factible. La poblaci&#243;n puede acabar en un caos sin remedio
al verse afectados los cantidatos aptos por el hecho de que las mutaciones
perjudiciales se desarrollen con m&#225;s rapidez de la que la selecci&#243;n
puede eliminarlas (cat&#225;strofe de errores), o puede retorcerse in&#250;tilmente,
incapaz de conseguir ning&#250;n aumento de la aptitud lo bastante grande
para que pueda ser seleccionado. Al igual que en la naturaleza, debe
haber un equilibrio o nunca se alcanzar&#225; una soluci&#243;n. La ventaja
que tiene un programador a este respecto es que, si ocurre esto, &#233;l
puede introducirle al programa valores diferentes -para el tama&#241;o
de la poblaci&#243;n, para la tasa de mutaci&#243;n, para la presi&#243;n selectiva-
y comenzar de nuevo. Obviamente, esto no es una opci&#243;n para los seres
vivos. Batten dice que ``no existe una regla en la evoluci&#243;n que diga
que algunos organismos de la poblaci&#243;n que evoluciona permanecer&#225;n
viables ocurran las mutaciones que ocurran'', pero tampoco existe
una regla as&#237; en los algoritmos gen&#233;ticos. 

<P>
Batten tambi&#233;n afirma que ``los AGs que he observado preservan artificialmente
a los mejores de la generaci&#243;n anterior y los protegen de las mutaciones
o la recombinaci&#243;n, en caso de que no se produzca algo mejor en la
siguiente generaci&#243;n''. Abordar&#233; esta cr&#237;tica en el siguiente punto.

<P>

<H3><A NAME="SECTION00071400000000000000">
Los AGs ignoran el coste de las sustituciones</A>
</H3>

<P>
La siguiente afirmaci&#243;n de Batten es que los AGs ignoran el 
``<a href="http://www.talkorigins.org/indexcc/CB/CB121.html">dilema de Haldane</a>'',
que dice que un alelo que contribuya menos a la aptitud de un organismo
tardar&#225; correspondientemente m&#225;s tiempo en fijarse en la poblaci&#243;n.
Obviamente, a lo que se refiere es a la t&#233;cnica de selecci&#243;n elitista,
que selecciona autom&#225;ticamente al mejor candidato de cada generaci&#243;n
sin importar lo peque&#241;a que sea su ventaja sobre sus competidores.
Tiene raz&#243;n al sugerir que, en la naturaleza, las ventajas competitivas
muy peque&#241;as pueden tardar en propagarse mucho m&#225;s. Los algoritmos
gen&#233;ticos no son un modelo exacto de la evoluci&#243;n biol&#243;gica a este
respecto. 

<P>
Sin embargo, esto no viene al caso. La selecci&#243;n elitista es una idealizaci&#243;n
de la evoluci&#243;n biol&#243;gica -un modelo de lo que pasar&#237;a en la naturaleza
si de vez en cuando no interviniese el azar. Como reconoce Batten,
el dilema de Haldane no afirma que una mutaci&#243;n ligeramente ventajosa
nunca quedar&#225; fijada en una poblaci&#243;n; afirma que tardar&#225; m&#225;s en hacerlo.
Sin embargo, cuando el tiempo de computaci&#243;n est&#225; muy demandado o
cuando un investigador de AGs desea obtener una soluci&#243;n con mayor
rapidez, puede ser deseable saltarse este proceso implementando el
elitismo. Un punto importante es que el elitismo no afecta a qu&#233; mutaciones
surgen, s&#243;lo asegura la selecci&#243;n de las mejores que surjan. No importar&#237;a
lo fuerte que fuera la selecci&#243;n si no ocurrieran mutaciones que incrementasen
la informaci&#243;n. En otras palabras, el elitismo acelera la convergencia
una vez que se ha descubierto una soluci&#243;n buena -no provoca un resultado
que no habr&#237;a ocurrido de otra manera. Por lo tanto, si los algoritmos
gen&#233;ticos con elitismo pueden producir informaci&#243;n nueva, entonces
tambi&#233;n lo puede hacer la evoluci&#243;n en la naturaleza. 

<P>
Adem&#225;s, no todos los AGs utilizan selecci&#243;n elitista. Muchos no lo
hacen, y en cambio dependen s&#243;lo de selecci&#243;n por ruleta de rueda
y otras t&#233;cnicas de muestreo estoc&#225;sticas, con no menor &#233;xito. Por
ejemplo, Koza et al 2003[<A
 HREF="algen.html#key-42">42</A>], p. 8-9, proporciona ejemplos
de 36 casos en los que la programaci&#243;n gen&#233;tica ha producido resultados
competitivos con los de los humanos, incluyendo la recreaci&#243;n autom&#225;tica
de 21 inventos patentados con anterioridad (seis de los cuales fueron
patentados durante o despu&#233;s de 2000), 10 de los cuales duplican la
funcionalidad de la patente de manera diferente, e incluyendo adem&#225;s
dos nuevos inventos patentables y cinco algoritmos nuevos que superan
a cualquier algoritmo humano escrito para el mismo prop&#243;sito. Como
declara el Dr. Koza en una referencia anterior al mismo trabajo (1999[<A
 HREF="algen.html#key-41">41</A>],
p. 1.070): ``No se utiliza la estrategia elitista''. Algunos art&#237;culos
m&#225;s citados en este ensayo, en los que no se utiliza el elitismo:
Robin et al. 2003[<A
 HREF="algen.html#key-54">54</A>]; Rizki, Zmuda y Tamburino 2002[<A
 HREF="algen.html#key-53">53</A>];
Chryssolouris y Subramaniam 2001[<A
 HREF="algen.html#key-16">16</A>]; Burke y Newall 1999[<A
 HREF="algen.html#key-11">11</A>];
Glen y Payne 1995[<A
 HREF="algen.html#key-28">28</A>]; Au, Chan y Yao 2003[<A
 HREF="algen.html#key-7">7</A>];
Jensen 2003[<A
 HREF="algen.html#key-38">38</A>]; Kewley y Embrechts 2002[<A
 HREF="algen.html#key-39">39</A>];
Williams, Crossley y Lang 2001[<A
 HREF="algen.html#key-64">64</A>]; Mahfoud y Mani 1996[<A
 HREF="algen.html#key-46">46</A>].
En todos estos casos, sin ning&#250;n mecanismo para asegurar que se seleccionaban
los mejores individuos de cada generaci&#243;n, sin eximir a estos individuos
del potencial cambio aleatorio perjudicial, los algoritmos gen&#233;ticos
siguen produciendo resultados poderosos, eficientes y competitivos
con los resultados humanos. Este hecho puede ser sorprendente para
creacionistas como Batten, pero es algo completamente esperado para
los defensores de la evoluci&#243;n.

<P>

<H3><A NAME="SECTION00071500000000000000">
Los AGs ignoran las limitaciones temporales para una generaci&#243;n</A>
</H3>

<P>
Esta cr&#237;tica es confusa. Batten afirma que una generaci&#243;n puede durar
microsegundos en un AG, mientras que en los seres vivos una generaci&#243;n
puede durar desde minutos hasta a&#241;os. Esto es cierto, pero no explica
c&#243;mo influye esto en la validez de los AGs como evidencia para la
evoluci&#243;n. Si un AG puede generar informaci&#243;n nueva, tarde el tiempo
que tarde, entonces la evoluci&#243;n natural puede hacer lo mismo sin
duda; que los AGs pueden efectivamente hacerlo es todo lo que trata
de demostrar este ensayo. La &#250;nica cuesti&#243;n restante ser&#237;a entonces
si la evoluci&#243;n biol&#243;gica ha tenido realmente el tiempo necesario
para causar un cambio significativo, y la respuesta a esta cuesti&#243;n
est&#225; a cargo de los bi&#243;logos, ge&#243;logos y f&#237;sicos, no de los programadores
inform&#225;ticos. 

<P>
Sin embargo, la respuesta que han proporcionado estos cient&#237;ficos
est&#225; en completo acuerdo con las escalas de tiempo evolutivas. Numerosas
l&#237;neas independientes de evidencia, incluyendo la
<a href="http://www.talkorigins.org/faqs/faq-age-of-earth.html#howold">dataci&#243;n
isocr&#243;nica radiom&#233;trica</a>,
los <a href="http://hubblesite.org/newscenter/newsdesk/archive/releases/2002/10">ritmos
de enfriamiento de las enanas blancas</a>,
la <a href="http://www.talkorigins.org/faqs/hovind/howgood-yea.html#proof6">no existencia en
la naturaleza de is&#243;topos con tiempos cortos de semideintegraci&#243;n</a>,
los <a href="http://www.nature.com/nsu/010607/010607-8.html">ritmos de alejamiento de las
galaxias lejanas</a>,
y el <a href="http://www.gsfc.nasa.gov/topstory/2003/0206mapresults.html">an&#225;lisis de la
radiaci&#243;n c&#243;smica de fondo</a>,
convergen hacia la misma conclusi&#243;n: una Tierra y un universo con
muchos miles de millones de a&#241;os, sin duda tiempo suficiente para
que la evoluci&#243;n haya producido toda la diversidad de vida que observamos
hoy para todas las estimaciones razonables.

<P>

<H3><A NAME="SECTION00071600000000000000">
Las altas tasas de mutaci&#243;n y reproducci&#243;n que emplean los AGs no
son realistas</A>
</H3>

<P>
Batten afirma, sin proporcionar ninguna evidencia o referencia que
le apoye, que los AGs ``producen com&#250;nmente cientos o miles de `descendientes'
por generaci&#243;n'', un ritmo que ni siquiera las bacterias, los organismos
biol&#243;gicos que se reproducen con mayor velocidad, pueden igualar. 

<P>
Esta cr&#237;tica erra el tiro de varias maneras. Primero, si la m&#233;trica
que se utiliza es (como deber&#237;a ser) el n&#250;mero de descendientes por
generaci&#243;n, en lugar del n&#250;mero de descendientes por unidad de tiempo
absoluto, entonces existen evidentemente organismos biol&#243;gicos que
pueden reproducirse a ritmos mayores que los de las bacterias y que
casi igualan los ritmos que Batten considera no realistas. Por ejemplo,
una sola rana puede poner miles de huevos de una vez, cada uno de
los cuales tiene el potencial de desarrollarse como adulto. De acuerdo,
la mayor&#237;a de &#233;stos normalmente no sobrevivir&#225;n debido a las limitaciones
de recursos y a la depredaci&#243;n, pero entonces la mayor&#237;a de la ``descendencia''
de cada generaci&#243;n en un AG tampoco sobrevivir&#225;. 

<P>
Segundo, y m&#225;s importante: un algoritmo gen&#233;tico trabajando para resolver
un problema no pretende representar a un solo organismo. En cambio,
un algoritmo gen&#233;tico es m&#225;s an&#225;logo a una poblaci&#243;n completa de organismos
-despu&#233;s de todo, son las poblaciones, y no los individuos, los que
evolucionan. Por supuesto, es completamente plausible que una poblaci&#243;n
tenga colectivamente cientos o miles de descendientes por generaci&#243;n.
(El creacionista Walter ReMine comete este mismo error con respecto
al programa ``weasel'' del Dr. Richard Dawkins. Vea este
<a href="http://talkorigins.org/origins/postmonth/sep99.html">Mensaje del Mes</a>
para m&#225;s informaci&#243;n). 

<P>
Adem&#225;s, dice Batten, la tasa de mutaci&#243;n es artificialmente alta en
los AGs, mientras que los seres vivos tienen una maquinaria de comprobaci&#243;n
de errores dise&#241;ada para limitar la tasa de mutaci&#243;n en aproximadamente
1 por cada 10.000 millones de par de bases (aunque esto es demasiado
poco -la cifra real est&#225; m&#225;s cerca de 1 por cada 1.000 millones.
Ver Dawkins 1996[<A
 HREF="algen.html#key-20">20</A>], p. 124). Por supuesto, esto es cierto.
Si los AGs mutasen a este ritmo, tardar&#237;an much&#237;simo en resolver problemas
reales. Evidentemente, lo que debe considerarse relevante es la tasa
de mutaci&#243;n relativa al tama&#241;o del genoma. La tasa de mutaci&#243;n debe
ser lo bastante alta para promover una cantidad suficiente de diversidad
en la poblaci&#243;n sin acabar con los individuos. Un ser humano corriente
posee entre una y cinco mutaciones; esto es perfectamente realista
para la descendencia de un AG.

<P>

<H3><A NAME="SECTION00071700000000000000">
Los AGs tienen genomas artificialmente peque&#241;os</A>
</H3>

<P>
El argumento de Batten de que el genoma de un algoritmo gen&#233;tico ``es
artificialmente peque&#241;o y s&#243;lo realiza una cosa'' est&#225; completamente
errado. En primer lugar, como ya hemos visto, no es cierto que un
AG s&#243;lo realice una cosa; hay muchos ejemplos de algoritmos gen&#233;ticos
dise&#241;ados espec&#237;ficamente para optimizar muchos par&#225;metros simult&#225;neamente,
a menudo muchos m&#225;s par&#225;metros de los que podr&#237;a manejar un dise&#241;ador
humano. 

<P>
&#191;Y exactamente c&#243;mo cuantifica Batten lo de ``artificialmente peque&#241;o''?
Muchos algoritmos evolutivos, como el programa gen&#233;tico de John Koza,
utilizan codificaciones de tama&#241;o variable donde el tama&#241;o de las
soluciones candidatas pueden crecer arbitrariamente. Batten afirma
que hasta los seres vivos m&#225;s sencillos tienen mucha m&#225;s informaci&#243;n
en su genoma que la que un AG haya producido nunca, pero si los organismos
vivos actuales tienen genomas relativamente grandes es porque se ha
ganado mucha complejidad en el curso de los miles de a&#241;os de evoluci&#243;n.
Como se&#241;ala el art&#237;culo <a href="http://www.talkorigins.org/faqs/abioprob/abioprob.html">
Probabilidad de abiog&#233;nesis</a>,
hay buenas razones para creer que los primeros organismos vivos eran
mucho m&#225;s sencillos que cualquier especie actual -las mol&#233;culas autorreplicadoras
probablemente no ten&#237;an m&#225;s de 30 o 40 subunidades, pudiendo quedar
especificadas perfectamente con los 1.800 bits de informaci&#243;n que
Batten reconoce que ha generado al menos un AG. Asimismo, los algoritmos
gen&#233;ticos son una t&#233;cnica muy nueva cuyo potencial completo todav&#237;a
no ha sido explotado; las propias computadoras digitales s&#243;lo tienen
unas pocas d&#233;cadas, y como se&#241;ala Koza (2003[<A
 HREF="algen.html#key-42">42</A>], p. 25),
las t&#233;cnicas de computaci&#243;n evolutiva han generado resultados cada
vez m&#225;s sustanciales y complejos durante los &#250;ltimos 15 a&#241;os, en sincron&#237;a
con el r&#225;pido aumento de la potencia computacional, a menudo referida
como la ``<a href="http://en.wikipedia.org/wiki/Moore's_law">ley de Moore</a>''.
Al igual que la vida primigenia era muy sencilla comparada con la
que vino despu&#233;s, es probable que los algoritmos gen&#233;ticos actuales,
a pesar de los impresionantes resultados que ya han producido, den
origen a resultados mucho m&#225;s importantes en el futuro.

<P>

<H3><A NAME="SECTION00071800000000000000">
Los AGs ignoran la posibilidad de que ocurran mutaciones por todo
el genoma</A>
</H3>

<P>
Aparentemente, Batten no comprende c&#243;mo funcionan los algoritmos gen&#233;ticos,
y lo demuestra realizando este argumento. Afirma que, en la vida real,
``las mutaciones ocurren por todo el genoma, no s&#243;lo en un gen o secci&#243;n
que especifique un caracter dado''. Esto es cierto, pero cuando dice
que lo mismo no es cierto para los AGs, se equivoca. Exactamente igual
que en los seres vivos, los AGs deben escardar los genes perjudiciales
al tiempo que seleccionan los beneficiosos. 

<P>
Batten continua afirmando que ``el propio programa est&#225; protegido
contra las mutaciones, s&#243;lo las secuencias objetivo mutan'', y si
el programa mutara, fallar&#237;a poco despu&#233;s. Esta cr&#237;tica, sin embargo,
es irrelevante. No existe raz&#243;n para que el programa que gobierna
a un AG tenga que mutar. El programa no es parte del algoritmo gen&#233;tico;
el programa es el que supervisa al algoritmo gen&#233;tico y produce las
mutaciones en las soluciones candidatas, que son lo que el programador
busca mejorar. El programa que ejecuta al AG no es an&#225;logo a la maquinaria
reproductiva de un organismo, una comparaci&#243;n que trata de establecer
Batten. En cambio, es an&#225;logo a las leyes naturales invariantes que
gobiernan los entornos en los que viven y se reproducen los seres
vivos, y no se espera que &#233;stas cambien ni necesitan ``protegerse''
de ello.

<P>

<H3><A NAME="SECTION00071900000000000000">
Los AGs ignoran los problemas de la complejidad irreducible</A>
</H3>

<P>
Utilizando el argumento de la ``<a href="http://talkorigins.org/faqs/behe.html">''
del creacionista de tipo tierra-vieja Michael Behe, Batten argumenta:
``Muchos caracteres biol&#243;gicos requieren la presencia de muchos componentes
distintos, funcionando juntos, para que el caracter pueda existir'',
mientras que esto no ocurre en los AGs. 

<P>
Sin embargo, es trivial demostrar que esta afirmaci&#243;n es falsa, ya
que los algoritmos gen&#233;ticos han producido sistemas irreduciblemente
complejos. Por ejemplo, el circuito reconocedor de voz que evolucion&#243;
el Dr. Adrian Thompson (Davidson 1997[<A
 HREF="algen.html#key-19">19</A>]) est&#225; compuesto
de 37 puertas l&#243;gicas. Cinco de ellas ni siquiera est&#225;n conectadas
al resto del circuito, aunque hacen falta las 37 para que el circuito
funcione; si cualquiera de ellas se desconecta de la fuente de alimentaci&#243;n,
todo el sistema deja de funcionar. Esto se ajusta a la definici&#243;n
de sistema complejo irreducible de Behe, y demuestra que un proceso
evolutivo puede producir cosas as&#237;. 

<P>
Debe se&#241;alarse que este argumento es el mismo que el primero, simplemente
presentado en un lenguaje distinto, y por tanto la refuntaci&#243;n es
la misma. La complejidad irreducible no es un problema para la evoluci&#243;n,
est&#233; la evoluci&#243;n ocurriendo en los seres vivos de la naturaleza o
en el silicio del procesador de una computadora.

<P>

<H3><A NAME="SECTION000711000000000000000">
Los AGs ignoran la poligenia, la pleiotrop&#237;a y otras complejidades
gen&#233;ticas</A>
</H3>

<P>
Batten argumenta que los AGs ignoran asuntos como la poligenia (la
determinaci&#243;n de un caracter por m&#250;ltiples genes), pleiotrop&#237;a (un
gen que afecte a m&#250;ltiples caracteres) y los genes dominantes y recesivos. 

<P>
Sin embargo, ninguna de estas afirmaciones es cierta. Los AGs no ignoran
la poligenia y la pleiotrop&#237;a: simplemente se permite que estas propiedades
surjan de manera natural en lugar de programarlas deliberadamente.
Es obvio que en cualquier sistema complejo interdependiente (es decir,
un sistema no lineal), la alteraci&#243;n o eliminaci&#243;n de una parte causar&#225;
una reacci&#243;n en cadena por todo el sistema; por tanto, los AGs incorporan
de manera natural la poligenia y la pleiotrop&#237;a. ``En la literatura
sobre algoritmos gen&#233;ticos, la interacci&#243;n entre par&#225;metros se conoce
como <SPAN  CLASS="textit">epistasis</SPAN> (un t&#233;rmino biol&#243;gico para la interacci&#243;n entre
genes). Cuando hay poca o ninguna epistasis, los algoritmos de b&#250;squeda
m&#237;nima [es decir, los trepacolinas **-A.M.] rinden mejor.
Los algoritmos gen&#233;ticos brillan cuando la epistasis es media o alta...''
(Haupt y Haupt 1998[<A
 HREF="algen.html#key-34">34</A>], p. 31, it&#225;licas originales). 

<P>
Igualmente, hay algunas implementaciones de algoritmos gen&#233;ticos que
s&#237; tienen cromosomas diploides y genes dominantes y recesivos (Goldberg
1989[<A
 HREF="algen.html#key-29">29</A>], p. 150; Mitchell 1996[<A
 HREF="algen.html#key-47">47</A>], p. 22). Sin
embargo, los que no lo son simplemente se parecen m&#225;s a los organismos
haploides, como las bacterias, que a los organismos diploides, como
los seres humanos. Ya que las bacterias est&#225;n entre los organismos
m&#225;s exitosos de este planeta (para ciertas medidas), tales AGs siguen
siendo un buen modelo de la evoluci&#243;n.

<P>

<H3><A NAME="SECTION000711100000000000000">
Los AGs no tienen m&#250;ltiples sistemas de lectura</A>
</H3>

<P>
Batten habla de la existencia de m&#250;ltiples sistemas de lectura en
los genomas de algunos seres vivos, en los que las secuencias de ADN
codifican distintas prote&#237;nas funcionales cuando se leen en direcciones
distintas o con distintos desplazamientos de inicio. Afirma que ``crear
un AG para generar una codificaci&#243;n con informaci&#243;n densa as&#237; parecer&#237;a
imposible''. 

<P>
Un reto as&#237; pide una respuesta, y aqu&#237; est&#225;: Soule y Ball 2001[<A
 HREF="algen.html#key-61">61</A>].
En este art&#237;culo, los autores presentan un algoritmo gen&#233;tico con
m&#250;ltiples sistemas de lectura y codificaci&#243;n densa, permiti&#233;ndole
almacenar m&#225;s informaci&#243;n que el tama&#241;o total de su genoma. Al igual
que los codones de tres nucle&#243;tidos especifican amino&#225;cidos en los
genomas de los seres vivos, en este AG los codones eran cadenas binarias
de cinco d&#237;gitos (hay por lo tanto 25 o 64 codones posibles, el mismo
n&#250;mero de codones en los sistemas biol&#243;gicos). Como los codones ten&#237;an
cinco d&#237;gitos de longitud, hab&#237;a cinco sistemas de lectura posibles.
La secuencia 11111 sirve como codon de ``comienzo'' y la 00000 como
codon de ``parada''; como el codon de comienzo y parada pueden aparecer
en cualquier lugar del genoma, la longitud de cada individuo era variable.
Las regiones del cromosoma que no ca&#237;an entre pares comienzo-parada
eran ignoradas. 

<P>
El AG se prob&#243; con cuatro problemas cl&#225;sicos de maximizaci&#243;n de funciones.
``Inicialmente, la mayor&#237;a de los bits no participan en ning&#250;n gen,
es decir, la mayor parte de un cromosoma no codifica nada. De nuevo,
esto es porque en los individuos iniciales aleatorios hay relativamente
pocos pares de codones comienzo-parada. Sin embargo, el n&#250;mero de
bits que no participan disminuye extremadamente r&#225;pido''. Durante
el curso de la ejecuci&#243;n, el AG puede incrementar la longitud efectiva
de su genoma introduciendo nuevos codones de comienzo en distintos
sistemas de lectura. Al final de la ejecuci&#243;n, ``la cantidad de superposiciones
es bastante alta. Muchos bits participan en varios genes (a menudo
en los cinco)''. En todos los problemas probados, el AG empez&#243;, de
media, con 5 variables especificadas; al final de la ejecuci&#243;n, ese
n&#250;mero se hab&#237;a incrementado hasta una media de 25. 

<P>
En los problemas de prueba, el AG con m&#250;ltiples sistemas de lectura
produjo soluciones significativamente mejores que un AG est&#225;ndar en
dos de los cuatro problemas, y mejores soluciones medias en los otros
dos. En uno de los problemas, el AG comprimi&#243; con &#233;xito 625 bits de
informaci&#243;n en un cromosoma de s&#243;lo 250 bits de longitud, utilizando
sistemas de lectura alternativos. Los autores tildan este comportamiento
de ``extremadamente sofisticado'' y concluyen que ``estos datos muestran
que un AG puede utilizar con &#233;xito sistemas de lectura a pesar de
la complejidad a&#241;adida'' y que ``es claro que un AG puede introducir
nuevos`genes' mientras sea necesario para resolver un cierto problema,
incluso con las dificultades impuestas al utilizar codones de comienzo
y parada y genes superpuestos''. 

<P>

<H3><A NAME="SECTION000711200000000000000">
Los AGs tienen objetivos predeterminados</A>
</H3>

<P>
Como muchas otras, esta objeci&#243;n demuestra que Batten no comprende
bien lo que es un algoritmo gen&#233;tico y c&#243;mo funciona. Argumenta que
los AGs, al contrario que la evoluci&#243;n, tienen objetivos predeterminados
y especificados desde el principio, y como ejemplo de esto, ofrece
el programa ``weasel'' del Dr. Richard Dawkins. 

<P>
Sin embargo, el programa weasel no es un verdadero algoritmo gen&#233;tico,
y no representa a los algoritmos gen&#233;ticos, precisamente por esa raz&#243;n.
No pretend&#237;a demostrar el poder de resoluci&#243;n de problemas de la evoluci&#243;n.
En cambio, su &#250;nica intenci&#243;n era mostrar la diferencia entre la selecci&#243;n
de un solo paso (la infame frase del ``tornado pasando por una chatarrer&#237;a
y produciendo un 747'') y la selecci&#243;n acumulativa de m&#250;ltiples pasos.
Ten&#237;a un objetivo espec&#237;fico predeterminado de antemano. Los algoritmos
gen&#233;ticos verdaderos, en cambio, no lo tienen. 

<P>
En un sentido m&#225;s general, los AGs s&#237; tienen un objetivo, a saber,
encontrar una soluci&#243;n aceptable a un problema dado. En este mismo
sentido, la evoluci&#243;n tambi&#233;n tiene un objetivo: producir organismos
que est&#233;n mejor adaptados a su entorno y por tanto experimenten un
mayor &#233;xito reproductivo. Pero al igual que la evoluci&#243;n es un proceso
sin objetivos espec&#237;ficos, los AGs no especifican de antemano c&#243;mo
debe resolverse un problema dado. La funci&#243;n de aptitud solamente
se establece para evaluar lo bien que funciona una soluci&#243;n candidata,
sin especificar ninguna forma de funcionar particular y sin juzgar
de qu&#233; manera inventa. La soluci&#243;n en s&#237; emerge luego mediante un
proceso de mutaci&#243;n y selecci&#243;n. 

<P>
La siguiente afirmaci&#243;n de Batten demuestra claramente que no entiende
lo que es un algoritmo gen&#233;tico. Afirma que ``quiz&#225;s si el programador
pudiera dar con un programa que permitiera que ocurriera cualquier
cosa y luego midiera la capacidad de supervivencia de los `organismos',
se estar&#237;a acercando a lo que se supone que hace la evoluci&#243;n'' -pero
as&#237; es exactamente como funcionan los algoritmos gen&#233;ticos. Generan
aleagoriamente soluciones candidatas y provocan mutaciones aleatorias
sobre ellas durante muchas generaciones. No se especifica ninguna
configuraci&#243;n de antemano; como dice Batten, se permite que ocurra
cualquier cosa. Como escribe John Koza (2003[<A
 HREF="algen.html#key-42">42</A>], p. 37),
repitiendo misteriosamente las palabras de Batten: ``Una caracter&#237;stica
importante... es que la selecci&#243;n [en la programaci&#243;n gen&#233;tica]
no es codiciosa. Los individuos que se sabe que son iferiores ser&#225;n
seleccionados hasta un cierto grado. No se garantiza que se seleccionar&#225;
el mejor individuo de la poblaci&#243;n. Adem&#225;s, el peor individuo de la
poblaci&#243;n no ser&#225; necesariamente exclu&#237;do. Puede ocurrir cualquier
cosa y nada est&#225; garantizado''. (Una secci&#243;n anterior trat&#243; este punto
concreto como uno de los puntos fuertes de los AGs). Y, sin embargo,
aplicando un filtro selectivo a estas candidatas mutadas aleatoriamente,
surgen soluciones eficientes, complejas y poderosas a problemas dif&#237;ciles,
soluciones que no fueron dise&#241;adas por ninguna inteligencia y que
a menudo pueden igualar o superar a las soluciones dise&#241;adas por los
humanos. La alegre afirmaci&#243;n de Batten de que ``por supuesto eso
es imposible'' est&#225; en contradicci&#243;n directa con la realidad.

<P>

<H3><A NAME="SECTION000711300000000000000">
Los AGs no generan informaci&#243;n nueva en realidad</A>
</H3>

<P>
La cr&#237;tica final de Batten dice as&#237;: ``Para un AG particular, necesitamos
preguntar qu&#233; parte de la `informaci&#243;n' generada por el programa est&#225;
en realidad especificada en el programa, en lugar de haber sido generada
de novo''. Acusa a los AGs de que a menudo no hacen m&#225;s que encontrar
la mejor manera de que ciertos m&#243;dulos interaccionen, cuendo los propios
m&#243;dulos y las maneras que tienen de interactuar est&#225;n especificadas
de antemano. 

<P>
Es dif&#237;cil saber qu&#233; hacer con este argumento. Cualquier problema
imaginable -los t&#233;rminos en una ecuaci&#243;n de c&#225;lculo, las mol&#233;culas
en una c&#233;lula, los componentes de un motor, el capital en un mercado
financiero- pueden expresarse en t&#233;rminos de m&#243;dulos que interact&#250;an
de cierta manera. Si todo lo que se tiene son m&#243;dulos sin especificar
que interact&#250;an de maneras sin especificar, no hay problema que resolver.
&#191;Significa esto que la soluci&#243;n a ning&#250;n problema requiere la generaci&#243;n
de informaci&#243;n nueva? 

<P>
Respecto a la cr&#237;tica de Batten sobre que la informaci&#243;n contenida
en la soluci&#243;n est&#233; especificada en el problema, la mejora manera
de mitigar sus preocupaciones es se&#241;alar la cantidad de ejemplos en
los que los AGs comienzan con poblaciones iniciales generadas aleatoriamente
que no est&#225;n de ninguna manera dise&#241;adas para ayudar al AG a resolver
el problema. Algunos de tales ejemplos son: Graham-Rowe 2004[<A
 HREF="algen.html#key-31">31</A>];
Davidson 1997[<A
 HREF="algen.html#key-19">19</A>]; Assion et al. 1998[<A
 HREF="algen.html#key-6">6</A>]; Giro,
Cyrillo y Galv&#227;o 2002[<A
 HREF="algen.html#key-27">27</A>]; Glen y Payne 1995[<A
 HREF="algen.html#key-28">28</A>];
Chryssolouris y Subramaniam 2001[<A
 HREF="algen.html#key-16">16</A>]; Williams, Crossley
y Lang 2001[<A
 HREF="algen.html#key-64">64</A>]; Robin et al. 2003[<A
 HREF="algen.html#key-54">54</A>]; Andreou,
Georgopoulos y Lokothanassis 2002[<A
 HREF="algen.html#key-4">4</A>]; Kewley y Embrechts
2002[<A
 HREF="algen.html#key-39">39</A>]; Rizki, Zmuda y Tamburino 2002[<A
 HREF="algen.html#key-53">53</A>]; y
especialmente Koza et al. 1999[<A
 HREF="algen.html#key-41">41</A>] y Koza et al. 2003[<A
 HREF="algen.html#key-42">42</A>],
que analiza el uso de programaci&#243;n gen&#233;tica para generar 36 inventos
competitivos con los humanos de dise&#241;os de circuitos anal&#243;gicos, biolog&#237;a
molecular, algoritmia, dise&#241;o de controladores industriales y otros
campos, todos comenzando con poblaciones de candidatas iniciales generadas
aleatoriamente. 

<P>
De acuerdo, algunos AGs s&#237; comienzan con soluciones generadas inteligentemente
que luego intentan mejorar, pero esto es irrelevante: en esos casos
el objetivo no es s&#243;lo devolver la soluci&#243;n de entrada inicial, sino
mejorarla mediante la producci&#243;n de informaci&#243;n nueva. En cualquier
caso, aunque la situaci&#243;n inicial sea como la describe Batten, encontrar
la manera m&#225;s eficiente mediante la que un cierto n&#250;mero de m&#243;dulos
puede interactuar bajo un conjunto dado de limitaciones puede ser
una tarea nada trivial, cuya soluci&#243;n implique una cantidad considerable
de informaci&#243;n nueva: el dise&#241;o de horarios en los aeropuertos internacionales,
por ejemplo, o las l&#237;neas de montaje de una f&#225;brica, o la distribuci&#243;n
de barriles entre almacenes y destiler&#237;as. De nuevo, los AGs han demostrado
su efectividad a la hora de resolver problemas cuya complejidad abrumar&#237;a
a cualquier humano. A la luz de las m&#250;ltiples innovaciones y soluciones
inesperadamente efectivas que ofrecen los AGs en muchos campos, la
afirmaci&#243;n de Batten de que ``la cantidad de informaci&#243;n nueva generada
(por un AG) es normalmente bastante trivial'' suena verdaderamente
hueca.

<P>

<H2><A NAME="SECTION00072000000000000000">
William Dembski</A>
</H2>

<P>
El reciente libro ``No Free Lunch: Why Specified Complexity Cannot
Be Purchased Without Intelligence'' (``No dan almuerzos gratis: por
qu&#233; la complejidad espec&#237;fica no puede conseguirse sin inteligencia''),
del creacionista de tipo tierra-vieja, el Dr. William Dembski, est&#225;
dedicado principalmente al tema de los algoritmos evolutivos y de
c&#243;mo se relacionan con la evoluci&#243;n biol&#243;gica. En particular, el libro
de Dembski trata de una cualidad elusiva que &#233;l llama ``complejidad
especificada'' que, seg&#250;n afirma &#233;l, est&#225; presente en gran abundancia
en los seres vivos, y que adem&#225;s los procesos evolutivos son incapaces
de generar, dejando como &#250;nica alternativa el ``dise&#241;o'' a un ``dise&#241;ador
inteligente'' sin identificar, mediante mecanismos sin especificar.
Para apoyar su caso, Dembski apela a un tipo de teoremas matem&#225;ticos
conocidos como teoremas No Dan Almuerzos Gratis que, seg&#250;n &#233;l, demuestran
que los algoritmos evolutivos, de media, no lo hacen mejor que una
b&#250;squeda ciega. 

<P>
Richard Wein ha escrito una refutaci&#243;n excelente y detallada de Dembski,
titulada <a href="http://www.talkorigins.org/design/faqs/nfl">Not a Free Lunch But a
Box of Chocolates</a>
(No un almuerzo gratis sino una caja de chocolates), y no reproducir&#233;
sus ideas aqu&#237;. En cambio, me centrar&#233; en el cap&#237;tulo 4 del libro
de Dembski, que trata en detalle de los algoritmos gen&#233;ticos. 

<P>
Dembski tiene un argumento principal en contra de los AGs, desarrollado
a fondo a lo largo de este cap&#237;tulo. Aunque no niega que pueden producir
resultados impresionantes -de hecho, dice que hay algo ``extra&#241;amente
persuasivo y casi m&#225;gico'' (p. 221) acerca del modo en el que los
AGs pueden encontrar soluciones diferentes a cualquier cosa dise&#241;ada
por seres humanos-, sostiene que su &#233;xito es debido a la complejidad
espec&#237;fica ``pasada de tapadillo'' dentro de ellos por sus dise&#241;adores
humanos y que posteriormente se manifiesta en las soluciones que producen.
``En otras palabras, toda la complejidad espec&#237;fica que obtenemos
de un algoritmo evolutivo debe aportarse primero en su construcci&#243;n
y en la informaci&#243;n que gu&#237;a al algoritmo. Los algoritmos evolutivos,
por tanto, no generan o crean complejidad espec&#237;fica, sino que simplemente
aprovechan la complejidad especificada que ya existe'' (p. 270). 

<P>
El primer problema evidente en el argumento de Dembski es &#233;ste. Aunque
su cap&#237;tulo sobre algoritmos evolutivos ocupa aproximadamente 50 p&#225;ginas,
las primeras 30 de ellas hablan de nada m&#225;s que el algoritmo ``weasel''
del Dr. Richard Dawkins, el cual, como ya se ha dicho, no es un verdadero
algoritmo gen&#233;tico y no es representativo de los algoritmos gen&#233;ticos.
Los otros dos ejemplos de Dembski -las antenas gen&#233;ticas de alambre
doblado de Edward Altshuler y Derek Linden y las redes neuronales
que juegan a las damas de Kumar Chellapilla y David Fogel- se introducen
tan s&#243;lo en las &#250;ltimas 10 p&#225;ginas del cap&#237;tulo y son tratadas en
tres p&#225;ginas, en combinaci&#243;n. Esto es una seria deficiencia, considerando
que el programa ``weasel'' no es representativo de la mayor parte
del trabajo que se hace en el campo de la computaci&#243;n evolutiva; no
obstante, analizar&#233; los argumentos de Dembski relacionados con &#233;l. 

<P>
Respecto al programa ``weasel'', Dembski afirma que ``Dawkins y sus
compa&#241;eros darwinistas utilizan este ejemplo para ilustrar el poder
de los algoritmos evolutivos'' (p. 182) y, de nuevo, ``los darwinistas...
est&#225;n encantados con el ejemplo CREO QUE SE PARECE A UNA COMADREJA
y lo consideran ilustrador del poder de los algoritmos evolutivos
para generar complejidad espec&#237;fica'' (p. 183). Esto es un
<a href="http://www.datanation.com/fallacies/straw.htm">hombre de paja</a>,
creaci&#243;n de Dembski (&#161;sobre todo porque el libro de Dawkins fue escrito
mucho antes de que Dembski acu&#241;ara ese t&#233;rmino!). Esto es lo que Dawkins
dice realmente del prop&#243;sito de su programa: 

<P>
<BLOCKQUOTE>
Lo que importa es la diferencia entre el tiempo que tarda la selecci&#243;n
<SPAN  CLASS="textit">acumulativa</SPAN>, y el tiempo que tardar&#237;a la misma computadora,
funcionando absolutamente a la misma velocidad, en alcanzar la frase
objetivo si estuviera obligada a utilizar el otro procedimiento de
<SPAN  CLASS="textit">selecci&#243;n de un solo paso</SPAN>: m&#225;s o menos un mill&#243;n de millones
de millones de millones de millones de a&#241;os'' (Dawkins 1996[<A
 HREF="algen.html#key-20">20</A>],
p. 49, it&#225;licas originales).

</BLOCKQUOTE>
En otras palabras, el programa ``weasel'' pretend&#237;a demostrar la diferencia
entre dos tipos distintos de selecci&#243;n: la selecci&#243;n de un solo paso,
en la que un resultado complejo est&#225; producido por puro azar en un
solo salto, y la selecci&#243;n acumulativa, en la que un resultado complejo
se construye poco a poco mediante un proceso de filtrado que preserva
preferentemente las mejoras. Nunca pretendi&#243; ser una simulaci&#243;n de
la evoluci&#243;n en su totalidad. 

<P>
La selecci&#243;n de un solo paso es el proceso absurdamente improbable
atacado con frecuencia en la literatura creacionista, compar&#225;ndolo
con un tornado pasando por una chatarrer&#237;a y produciendo un avi&#243;n
747, o una explosi&#243;n en una imprenta produciendo un diccionario. La
selecci&#243;n acumulativa es lo que realmente utiliza la evoluci&#243;n. Utilizando
la selecci&#243;n de un solo paso para alcanzar un resultado funcional
de alguna complejidad significativa, hanr&#237;a que esperar, de media,
muchas veces la edad actual del universo. Utilizando selecci&#243;n acumulativa,
por contra, se puede alcanzar ese mismo resultado en un periodo de
tiempo comparativamente muy corto. El objetivo del programa ``weasel''
de Dawkins era demostrar esta diferencia, y era el &#250;nico objetivo
del programa. En una nota al pie de este cap&#237;tulo, Dembski escribe:
``Es curioso c&#243;mo se recicla el ejemplo de Dawkins sin ninguna indicaci&#243;n
de las dificultades fundamentales que lo acompa&#241;an'' (p. 230), pero
tan s&#243;lo los conceptos err&#243;neos de las mentes de los creacionistas
como Dembski y Batten, que atacan al programa ``weasel'' por no demostrar
algo que nunca pretend&#237;a demostrar, son los que dan lugar a estas
``dificultades''. 

<P>
A diferencia de todos los ejemplos de algoritmo evolutivo tratados
en este ensayo, el programa ``weasel'' tiene ciertamente un resultado
especificado de antemano, y la calidad de las soluciones que genera
se juzga compar&#225;ndola explic&#237;tamente con ese resultado especificado
de antemano. Por tanto, Dembski tiene toda la raz&#243;n cuando dice que
el programa ``weasel'' no genera informaci&#243;n nueva. No obstante, luego
realiza un salto gigantesco y completamente injustificado, al extrapolar
esta conclusi&#243;n a todos los algoritmos evolutivos: ``Como &#250;nica posibilidad
que puede alcanzar el algoritmo evolutivo de Dawkins, la secuencia
objetivo tiene de hecho una complejidad m&#237;nima... Por lo tanto,
los algoritmos evolutivos son incapaces de generar verdadera complejidad''
(p. 182). Hasta Dembski parece reconocer esto cuando escribe: ``...la
mayor&#237;a de los algoritmos evolutivos de la literatura est&#225;n programados
para buscar en un espacio de soluciones posibles a un problema hasta
que encuentran una respuesta -no, como hace Dawkins, programando
expl&#237;citamente la respuesta de antemano'' (p. 182). Pero luego, habiendo
dado una raz&#243;n perfectamente buena de por qu&#233; el programa ``weasel''
no es representativo de los AGs en conjunto, &#161;prosigue inexplicablemente
realizando esa falaz generalizaci&#243;n! 

<P>
En realidad, el programa ``weasel'' es significativamente distinto
de la mayor&#237;a de los algoritmos gen&#233;ticos, y por tanto el argumento
por analog&#237;a de Dembski no se sostiene. Los verdaderos algoritmos
evolutivos, como los ejemplos examinados en este ensayo, no buscan
simplemente un camino hacia soluciones ya descubiertas por otros m&#233;todos
-en cambio, se les presenta un problema para el que no se conoce
una soluci&#243;n &#243;ptima de antemano, y se les pide que descubran esa soluci&#243;n
por su cuenta. En realidad, si los algoritmos gen&#233;ticos no pudieran
hacer m&#225;s que redescubrir soluciones ya programadas dentro de ellos,
&#191;qu&#233; sentido tendr&#237;a utilizarlos? Ser&#237;a un ejercicio de redundancia.
Sin embargo, el amplio inter&#233;s cient&#237;fico (y comercial) por los AGs
demuestra que hay mucha m&#225;s sustancia en ellos que en el ejemplo bastante
trivial al que Dembski pretende reducir todo este campo. 

<P>
Despu&#233;s de colocar y luego derribar este hombre de paja, Dembski avanza
hacia su siguiente l&#237;nea de argumentaci&#243;n: que la complejida espec&#237;fica
exhibida por los resultados de los algoritmos evolutivos m&#225;s representativos
ha sido ``pasada de tapadillo'' por los dise&#241;adores dentro del algoritmo,
al igual que en el programa ``weasel''. ``Pero siempre encontramos
que cuando parece generarse complejidad espec&#237;fica de la nada, en
realidad ha sido cargada de antemano, pasada de tapadillo u ocultada
a la vista'' (p. 204). Dembski sugiere que el ``escondite'' m&#225;s com&#250;n
de la complejidad espec&#237;fica est&#225; en la funci&#243;n de aptitud del AG.
``Lo que ha hecho [el algoritmo evolutivo] es aprovecharse de
la complejidad espec&#237;fica inherente a la funci&#243;n de aptitud y la ha
utilizado para buscar y encontrar el objetivo...'' (p. 194).
Dembski prosigue argumentando que, antes de que un AE pueda buscar
una soluci&#243;n en un paisaje adaptativo dado, antes debe emplearse alg&#250;n
mecanismo para seleccionar ese paisaje adaptativo de entre lo que
&#233;l llama un espacio de fases de todos los posibles paisajes adaptativos,
y que si ese mecanismo es tambi&#233;n evolutivo, antes debe emplearse
alg&#250;n otro mecanismo para seleccionar su funci&#243;n de aptitud de un
espacio de fases a&#250;n mayor, y as&#237; sucesivamente. Dembski concluye
que la &#250;nica manera de detener esta regresi&#243;n infinita es mediante
la inteligencia, la cual, seg&#250;n el, posee la irreducible y misteriosa
habilidad de seleccionar una funci&#243;n de aptitud de un espacio de fases
dado sin recurrir a espacios de fases de mayor orden. ``S&#243;lo existe
un generador de complejidad espec&#237;fica conocido, y &#233;ste es la inteligencia''
(p. 207). 

<P>
Dembski tiene raz&#243;n cuando dice que la funci&#243;n de aptitud ``gu&#237;a a
un algoritmo evolutivo hacia el objetivo'' (p. 192). Sin embargo,
no tiene raz&#243;n cuando afirma que seleccionar la funci&#243;n de aptitud
correcta es un proceso que requiera la generaci&#243;n de m&#225;s complejidad
espec&#237;fica de la que el propio AE produce. Como escribe Koza (1999[<A
 HREF="algen.html#key-41">41</A>],
p. 39), la funci&#243;n de aptitud le dice a un algoritmo evolutivo ``qu&#233;
hay que hacer'', no ``c&#243;mo hacerlo''. A diferencia del nada representativo
programa ``weasel'', normalmente la funci&#243;n de aptitud de un AE no
especifica ninguna forma particular que la soluci&#243;n deba adquirir,
y por tanto no se puede decir que contribuya a la ``complejidad espec&#237;fica''
de la soluci&#243;n evolucionada en ning&#250;n sentido. 

<P>
Un ejemplo ilustrar&#225; la idea con mayor detalle. Dembski afirma que
en el experimento de las damas de Chellapilla y Fogel, su elecci&#243;n
de mantener constante el criterio de victoria entre juego y juego
``insert&#243; una enorme cantidad de complejidad espec&#237;fica'' (p. 223).
Desde luego, es cierto que el producto final de este proceso exhib&#237;a
una gran cantidad de complejidad espec&#237;fica (se defina como se defina
ese t&#233;rmino). Pero &#191;es cierto que la medida de aptitud elegida contuviese
tanta complejidad espec&#237;fica? Esto es lo que dicen realmente Chellapilla
y Fogel: 

<P>
<BLOCKQUOTE>
Para apreciar el nivel de juego que se hab&#237;a conseguido, puede ser
&#250;til considerar el siguiente experimento mental. Suponga que le piden
jugar a un juego en un tablero de ocho por ocho casillas con colores
alternos. Hay 12 piezas en cada lado ordenadas de una cierta manera
antes de empezar el juego. Le dicen las reglas de movimiento de las
piezas (es decir, el movimiento diagonal, comer forzosamente, la promoci&#243;n)
y que se pueden comer piezas. Sin embargo, no le dicen si comer piezas
es favorable o desfavorable (hay una versi&#243;n de las damas llamada
`damas suicidas', en la que el objetivo es `perder' lo m&#225;s r&#225;pidamente
posible) o incluso si constituye informaci&#243;n relevante. Y lo que es
m&#225;s importante, no le dicen cu&#225;l es el objetivo del juego. Usted simplente
realiza movimientos y en alg&#250;n momento un observador externo declara
que el juego ha acabado. No obstante, no le proporcionan informaci&#243;n
de si ha ganado, perdido o empatado. Los &#250;nicos datos que usted recibe
llegan tras un m&#237;nimo de cinco partidas y se ofrecen en la forma de
una puntuaci&#243;n global. Por tanto, no puede saber con certeza qu&#233; juegos
contribuyeron a la puntuaci&#243;n global ni en qu&#233; grado. Su reto consiste
en inducir los movimientos apropiados en cada partida tan s&#243;lo a partir
de esta burda informaci&#243;n'' (Chellapilla y Fogel 2001[<A
 HREF="algen.html#key-13">13</A>],
p. 427). 

</BLOCKQUOTE>
La afirmaci&#243;n de Dembski de que esta medida de la aptitud insert&#243;
una ``enorme'' cantidad de complejidad espec&#237;fica excede los l&#237;mites
de lo absurdo. Si se le diera la misma informaci&#243;n a un ser humano
que nunca hubiera o&#237;do hablar de las damas, y meses despu&#233;s volvi&#233;ramos
para descubrir que se ha convertido en un jugador experto a nivel
internacional, &#191;podemos conclu&#237;r que se ha generado complejidad espec&#237;fica? 

<P>
Dembski afirma que para refutar su argumento, ``hace falta demostrar
que encontrar la informaci&#243;n que gu&#237;a a un algoritmo evolutivo hacia
un objetivo es sustancialmente m&#225;s f&#225;cil que encontrar el objetivo
directamente mediante una b&#250;squeda ciega'' (p. 204). Sostengo que
&#233;se es precisamente el caso. Intuitivamente, no debe sorprender que
la funci&#243;n de aptitud contenga menos informaci&#243;n que la soluci&#243;n evolucionada.
&#201;sta es precisamente la raz&#243;n por la que los AGs han hallado un uso
tan amplio: es m&#225;s f&#225;cil (requiere menos informaci&#243;n) escribir una
funci&#243;n de aptitud que mida lo buena que es una soluci&#243;n que dise&#241;ar
una buena soluci&#243;n desde cero. 

<P>
En t&#233;rminos m&#225;s informales, consideremos los dos ejemplos de Dembski,
la antena gen&#233;tica de alambre doblado y la red neuronal jugadora de
damas evolucionada llamada Anaconda. Obtener una estrategia ganadora
requiere una gran cantidad de informaci&#243;n detallada sobre el juego
de las damas (considere a Chinook y su enorme biblioteca de finales
de partida). Sin embargo, no hace falta una informaci&#243;n igualmente
detallada para reconocer una estrategia as&#237; cuando se la ve: todo
lo que necesitamos observar es que esa estrategia vence consistentemente
a sus oponentes. De manera similar, una persona que no supiera nada
sobre c&#243;mo dise&#241;ar una antena que radie uniformemente en una regi&#243;n
hemisf&#233;rica en un cierto rango de frecuencias, podr&#237;a sin embargo
probar una antena as&#237; y verificar si funciona como se pretende. En
ambos casos, determinar lo que constituye una aptitud alta es mucho
m&#225;s f&#225;cil (requiere menos informaci&#243;n) que averiguar c&#243;mo conseguir
una aptitud alta. 

<P>
De acuerdo, aunque requiera menos informaci&#243;n escoger una funci&#243;n
de aptitud para un problema dado que resolver verdaderamente el problema
definido por esa funci&#243;n de aptitud, s&#237; que hace falta algo de informaci&#243;n
para especificar la funci&#243;n de aptitud en primer lugar, y es una cuesti&#243;n
leg&#237;tima preguntar de d&#243;nde viene esta informaci&#243;n inicial. Dembski
todav&#237;a puede preguntar sobre el origen de la inteligencia humana
que nos permite decidir resolver un problema en lugar de otro, o sobre
el origen de las leyes naturales del cosmos que hacen posible que
la vida exista y florezca y que ocurra la evoluci&#243;n. &#201;stas son preguntas
v&#225;lidas, y Dembski tiene derecho a pensar en ellas. Sin embargo, en
este punto - aparentemente inadvertido por el propio Dembski- se
ha alejado de su argumento inicial. Ya no est&#225; afirmando que la evoluci&#243;n
no pueda ocurrir; en cambio, esencialmente est&#225; preguntando por qu&#233;
vivimos en un universo en el que puede ocurrir la evoluci&#243;n. En otras
palabras, Dembski no parece darse cuenta de que la conclusi&#243;n l&#243;gica
de su argumento es la evoluci&#243;n te&#237;sta. Es perfectamente compatible
con un Dios que (como muchos cristianos, incluyendo el bi&#243;logo evolutivo
Kenneth Miller, creen) utiliz&#243; la evoluci&#243;n como su herramienta creativa,
y cre&#243; el universo para hacer que fuera no s&#243;lo probable, sino seguro. 

<P>
Concluir&#233; aclarando algunos conceptos err&#243;neos menores adicionales
del cap&#237;tulo 4 de No Free Lunch. Para empezar, aunque Dembski, al
contrario que Batten, est&#225; claramente informado acerca del campo de
la optimizaci&#243;n multiobjetivo, afirma err&#243;neamente que ``hasta que
no se consiga alguna forma de univalencia, la optimizaci&#243;n no puede
comenzar'' (p. 186). El an&#225;lisis de los algoritmos gen&#233;ticos multiobjetivo
de este ensayo muestran el error de esta afirmaci&#243;n. Quiz&#225; otras t&#233;cnicas
de dise&#241;o tengan esta restricci&#243;n, pero una de las virtudes de los
AGs es precisamente que pueden establecer contrapartidas y optimizar
varios objetivos mutuamente exclusivos simult&#225;neamente, y luego un
supervisor humano puede elegir la soluci&#243;n que mejor consiga los resultados
esperados del grupo final de soluciones paretianas. No es necesario
ning&#250;n m&#233;todo para combinar m&#250;ltiples criterios en uno. 

<P>
Dembski tambi&#233;n afirma que los AGs ``parecen menos expertos a la hora
de constru&#237;r sistemas integrados que requieran de m&#250;ltiples partes
para realizar funciones novedosas'' (p. 237). La gran cantidad de
ejemplos detallados en este ensayo (en particular, la utilizaci&#243;n
de John Koza de la programaci&#243;n gen&#233;tica para dise&#241;ar circuitos anal&#243;gicos
complejos) demuestran que esta afirmaci&#243;n tambi&#233;n es falsa. 

<P>
Finalmente, Dembski menciona que INFORMS, la organizaci&#243;n profesional
de la comunidad de investigaci&#243;n de operaciones, le presta muy poca
atenci&#243;n a los AGs, y esto ``es una raz&#243;n para ser esc&#233;ptico acerca
del alcance y poder general de esta t&#233;cnica'' (p. 237). Sin embargo,
s&#243;lo porque una sociedad cient&#237;fica particular no est&#233; haciendo un
uso generalizado de los AGs no significa que esos usos no sean generalizados
en otros sitios o en general, y este ensayo ha procurado demostrar
que &#233;ste es ciertamente el caso. Las t&#233;cnicas evolutivas han hallado
una amplia variedad de usos en pr&#225;cticamente todos los campos de la
ciencia que merece la pena nombrar, adem&#225;s de muchas empresas del
sector comercial. Aqu&#237; hay una lista parcial: 

<P>

<UL>
<LI>Lockheed Martin (Gibbs 1996[<A
 HREF="algen.html#key-25">25</A>])
</LI>
<LI>GlaxoSmithKline (Gillet 2002[<A
 HREF="algen.html#key-26">26</A>])
</LI>
<LI>LBS Capital Management (Naik 1996[<A
 HREF="algen.html#key-48">48</A>])
</LI>
<LI>First Quadrant (Begley and Beals 1995[<A
 HREF="algen.html#key-9">9</A>])
</LI>
<LI>Texas Instruments (Begley and Beals 1995[<A
 HREF="algen.html#key-9">9</A>])
</LI>
<LI>U.S. West (Begley and Beals 1995[<A
 HREF="algen.html#key-9">9</A>])
</LI>
<LI>John Deere &amp; Co. (Petzinger 1995[<A
 HREF="algen.html#key-50">50</A>])
</LI>
<LI>Volvo (Rao 1998[<A
 HREF="algen.html#key-52">52</A>])
</LI>
<LI>Ascent Technology (Wired 2002[<A
 HREF="algen.html#key-1">1</A>])
</LI>
<LI>Boeing (Ashley 1992[<A
 HREF="algen.html#key-5">5</A>])
</LI>
<LI>British Petroleum (Lemley 2001[<A
 HREF="algen.html#key-45">45</A>])
</LI>
<LI>Ford Motor Company (Lemley 2001[<A
 HREF="algen.html#key-45">45</A>])
</LI>
<LI>Unilever (Lemley 2001[<A
 HREF="algen.html#key-45">45</A>])
</LI>
<LI>United Distillers and Vintners (Lemley 2001[<A
 HREF="algen.html#key-45">45</A>])
</LI>
</UL>
En contraste, dada la escasez de descubrimientos e investigaci&#243;n cient&#237;fica
estimulados por el dise&#241;o inteligente, Dembski no se encuentra en
posici&#243;n de quejarse de la falta de aplicaciones pr&#225;cticas. El dise&#241;o
inteligente es una hip&#243;tesis vac&#237;a, que no nos dice nada m&#225;s que ``alg&#250;n
dise&#241;ador hizo algo, de alguna manera, en alg&#250;n momento, para provocar
este resultado''. En contraste, este ensayo ha demostrado con suerte
que la evoluci&#243;n es una estrategia de resoluci&#243;n de problemas llena
de aplicaciones pr&#225;cticas.

<P>

<H1><A NAME="SECTION00080000000000000000">
Conclusi&#243;n</A>
</H1>

<P>
Hasta los creacionistas encuentran imposible negar que la combinaci&#243;n
de la mutaci&#243;n y la selecci&#243;n natural puede producir adaptaci&#243;n. No
obstante, todav&#237;a siguen intentando justificar su rechazo a la evoluci&#243;n
dividiendo el proceso evolutivo en dos categor&#237;as -``microevoluci&#243;n''
y ``macroevoluci&#243;n''- y afirmando que s&#243;lo la segunda es controvertida,
y que cualquier cambio evolutivo que podemos observar es s&#243;lo un ejemplo
de la primera. 

<P>
Veamos. La microevoluci&#243;n y la macroevoluci&#243;n son t&#233;rminos que tienen
significado para los bi&#243;logos; se definen, respectivamente, como evoluci&#243;n
por debajo del nivel de especies y evoluci&#243;n al nivel de especies
o por encima. Pero la diferencia crucial entre el modo en el que los
creacionistas utilizan estos t&#233;rminos y el modo en el que lo hacen
los cient&#237;ficos es que los cient&#237;ficos reconocen que los dos son fundamentalmente
el mismo proceso con los mismos mecanismos, tan s&#243;lo operando a diferentes
escalas. Sin embargo, los creacionistas est&#225;n obligados a postular
alg&#250;n tipo de brecha infranqueable que los separa, para poder negar
que los procesos de cambio y adaptaci&#243;n que vemos en la actualidad
puedan extrapolarse para producir toda la diversidad que vemos en
el mundo de los seres vivos. 

<P>
No obstante, los algoritmos gen&#233;ticos hacen que esta idea sea insostenible,
al demostrar la naturaleza sin junturas del proceso evolutivo. Consideremos,
por ejemplo, un problema que consista en programar un circuito para
que discrimine entre un tono de 1 kilohercio y un tono de 10 kilohercios,
y responda respectivamente con salidas uniformes de 0 y 5 voltios.
Digamos que tenemos una soluci&#243;n candidata que puede discriminar con
precisi&#243;n entre los dos tonos, pero sus salidas no son lo bastante
uniformes como se requiere; producen peque&#241;as ondulaciones en lugar
del voltaje constante requerido. Supuestamente, de acuerdo con las
ideas creacionistas, cambiar este circuito de su estado presente a
la soluci&#243;n perfecta ser&#237;a ``microevoluci&#243;n'', un cambio peque&#241;o dentro
de las capacidades de la mutaci&#243;n y la selecci&#243;n. Pero, sin duda -argumentar&#237;a
un creacionista-, llegar a este mismo estado final desde una ordenaci&#243;n
inicial completamente aleatoria de componentes ser&#237;a ``macroevoluci&#243;n'',
y estar&#237;a m&#225;s all&#225; del alcance de un proceso evolutivo. Sin embargo,
los algoritmos gen&#233;ticos han sido capaces de conseguir ambas cosas:
evolucionar el sistema a partir de una ordenaci&#243;n aleatoria hasta
la soluci&#243;n casi perfecta y finalmente hasta la soluci&#243;n perfecta
y &#243;ptima. No surgi&#243; ninguna dificultad o brecha insalvable en ning&#250;n
punto del camino. En ning&#250;n momento hizo falta intervenci&#243;n humana
para montar un conjunto de componentes irreduciblemente complejo (a
pesar del hecho de que el producto final s&#237; contiene tal cosa) o para
``guiar'' al sistema evolutivo a trav&#233;s de alg&#250;n pico dificultoso.
El circuito evolucion&#243;, sin la ayuda de ninguna orientaci&#243;n inteligente,
desde un estado completamente aleatorio y no funcional hasta un estado
rigurosamente complejo, eficiente y &#243;ptimo. &#191;C&#243;mo puede no ser esto
una demostraci&#243;n experimental convincente del poder de la evoluci&#243;n? 

<P>
Se dice que la evoluci&#243;n cultural humana ha reemplazado a la biol&#243;gica
-que nosotros, como especie, hemos llegado a un punto en el que somos
capaces de controlar conscientemente nuestra sociedad, nuestro entorno
y hasta nuestros genes al nivel suficiente para hacer que el proceso
evolutivo sea irrelevante. Se dice que los caprichos culturales de
nuestra cambiante sociedad son los que determinan la aptitud hoy en
d&#237;a, en lugar de la marcha enormemente lenta, en comparaci&#243;n, de la
mutaci&#243;n gen&#233;tica y la selecci&#243;n natural. En cierto sentido, esto
puede ser perfectamente cierto. 

<P>
Pero en otro sentido, nada podr&#237;a estar m&#225;s lejos de la verdad. La
evoluci&#243;n es un proceso de resoluci&#243;n de problemas cuyo poder s&#243;lo
comenzamos a comprender y explotar; a pesar de esto, ya est&#225; funcionando
por todas partes, moldeando nuestra tecnolog&#237;a y mejorando nuestras
vidas, y, en el futuro, estos usos no har&#225;n sino multiplicarse. Sin
un conocimiento detallado del proceso evolutivo no habr&#237;an sido posibles
ninguno de los incontables avances que le debemos a los algoritmos
gen&#233;ticos. Aqu&#237; hay una lecci&#243;n que deben aprender los que niegan
el poder de la evoluci&#243;n y los que niegan que el conocimiento de ella
tenga beneficios pr&#225;cticos. Por incre&#237;ble que pueda parecer, la evoluci&#243;n
funciona. Como lo expresa el poeta Lord Byron: ``Es extra&#241;o pero cierto;
porque la verdad siempre es extra&#241;a, m&#225;s extra&#241;a que la ficci&#243;n.''

<P>
 
<H2><A NAME="SECTION00090000000000000000">
Bibliografía</A>
</H2><DL COMPACT><DD><P></P><DT><A NAME="key-1">1</A>
<DD>``Adaptive Learning: Fly the Brainy Skies.'' <SPAN  CLASS="textit">Wired</SPAN>, vol.10,
no.3 (marzo de 2002). Disponible <a href=http://www.wired.com/wired/archive/10.03/everywhere.html?pg=2">en l&#237;nea</a>.
<P></P><DT><A NAME="key-2">2</A>
<DD>Altshuler, Edward y Derek Linden. ``Design of a wire antenna using
a genetic algorithm.'' <SPAN  CLASS="textit">Journal of Electronic Defense</SPAN>, vol.20,
no.7, p.50-52 (julio de 1997).
<P></P><DT><A NAME="key-3">3</A>
<DD>Andre, David y Astro Teller. ``Evolving team Darwin United.'' En <SPAN  CLASS="textit">RoboCup-98:
Robot Soccer World Cup II</SPAN>, Minoru Asada and Hiroaki Kitano (eds).
Lecture Notes in Computer Science, vol.1604, p.346-352. Springer-Verlag,
1999.
<BR>
<BR>Ver tambi&#233;n: Willihnganz, Alexis. ``Software that writes software.''
<SPAN  CLASS="textit">Salon</SPAN>, 10 de agosto de 1998. Disponible <a href="http://www.salon.com/tech/feature/1999/08/10/genetic_programming">en l&#237;nea</a>.
<P></P><DT><A NAME="key-4">4</A>
<DD>Andreou, Andreas, Efstratios Georgopoulos y Spiridon Likothanassis.
``Exchange-rates forecasting: A hybrid algorithm based on genetically
optimized adaptive neural networks.'' <SPAN  CLASS="textit">Computational Economics</SPAN>,
vol.20, no.3, p.191-210 (diciembre de 2002).
<P></P><DT><A NAME="key-5">5</A>
<DD>Ashley, Steven. ``Engineous explores the design space.'' <SPAN  CLASS="textit">Mechanical
Engineering</SPAN>, febrero de 1992, p.49-52.
<P></P><DT><A NAME="key-6">6</A>
<DD>Assion, A., T. Baumert, M. Bergt, T. Brixner, B. Kiefer, V. Seyfried,
M. Strehle y G. Gerber. ``Control of chemical reactions by feedback-optimized
phase-shaped femtosecond laser pulses.'' <SPAN  CLASS="textit">Science</SPAN>, vol.282,
p.919-922 (30 de octubre de 1998).
<P></P><DT><A NAME="key-7">7</A>
<DD>Au, Wai-Ho, Keith Chan, y Xin Yao. ``A novel evolutionary data mining
algorithm with applications to churn prediction.'' <SPAN  CLASS="textit">IEEE Transactions
on Evolutionary Computation</SPAN>, vol.7, no.6, p.532-545 (diciembre de
2003).
<P></P><DT><A NAME="key-8">8</A>
<DD>Beasley, J.E., J. Sonander y P. Havelock. ``Scheduling aircraft landings
at London Heathrow using a population heuristic.'' <SPAN  CLASS="textit">Journal of
the Operational Research Society</SPAN>, vol.52, no.5, p.483-493 (mayo de
2001).
<P></P><DT><A NAME="key-9">9</A>
<DD>Begley, Sharon y Gregory Beals. ``Software au naturel.'' <SPAN  CLASS="textit">Newsweek</SPAN>,
8 de mayo de 1995, p.70.
<P></P><DT><A NAME="key-10">10</A>
<DD>Benini, Ernesto y Andrea Toffolo. ``Optimal design of horizontal-axis
wind turbines using blade-element theory and evolutionary computation.''
<SPAN  CLASS="textit">Journal of Solar Energy Engineering</SPAN>, vol.124, no.4, p.357-363
(noviembre de 2002).
<P></P><DT><A NAME="key-11">11</A>
<DD>Burke, E.K. y J.P. Newall. ``A multistage evolutionary algorithm for
the timetable problem.'' <SPAN  CLASS="textit">IEEE Transactions on Evolutionary Computation</SPAN>,
vol.3, no.1, p.63-74 (abril de 1999).
<P></P><DT><A NAME="key-12">12</A>
<DD>Charbonneau, Paul. ``Genetic algorithms in astronomy and astrophysics.''
<SPAN  CLASS="textit">The Astrophysical Journal Supplement Series</SPAN>, vol.101, p.309-334
(diciembre de 1995).
<P></P><DT><A NAME="key-13">13</A>
<DD>Chellapilla, Kumar y David Fogel. ``Evolving an expert checkers playing
program without using human expertise.'' <SPAN  CLASS="textit">IEEE Transactions on
Evolutionary Computation</SPAN>, vol.5, no.4, p.422-428 (agosto de 2001).
Disponible <a href="http://www.natural-selection.com/NSIPublicationsOnline.htm">en l&#237;nea</a>.
<P></P><DT><A NAME="key-14">14</A>
<DD>Chellapilla, Kumar y David Fogel. ``Anaconda defeats Hoyle 6-0: a
case study competing an evolved checkers program against commercially
available software.'' En <SPAN  CLASS="textit">Proceedings of the 2000 Congress on
Evolutionary Computation</SPAN>, p.857-863. IEEE Press, 2000. Disponible
<a href="http://www.natural-selection.com/NSIPublicationsOnline.htm">en l&#237;nea</a>.
<P></P><DT><A NAME="key-15">15</A>
<DD>Chellapilla, Kumar y David Fogel. ``Verifying Anaconda's expert rating
by competing against Chinook: experiments in co-evolving a neural
checkers player.'' <SPAN  CLASS="textit">Neurocomputing</SPAN>, vol.42, no.1-4, p.69-86
(enero de 2002).
<P></P><DT><A NAME="key-16">16</A>
<DD>Chryssolouris, George y Velusamy Subramaniam. ``Dynamic scheduling
of manufacturing job shops using genetic algorithms.'' <SPAN  CLASS="textit">Journal
of Intelligent Manufacturing</SPAN>, vol.12, no.3, p.281-293 (junio de 2001).
<P></P><DT><A NAME="key-17">17</A>
<DD>Coale, Kristi. ``Darwin in a box.'' <SPAN  CLASS="textit">Wired News</SPAN>, 14 de julio
de 1997. Disponible <a href="http://www.wired.com/news/technology/0,1282,5152,00.html">en l&#237;nea</a>.
<P></P><DT><A NAME="key-18">18</A>
<DD>Coello, Carlos. ``An updated survey of GA-based multiobjective optimization
techniques.'' <SPAN  CLASS="textit">ACM Computing Surveys</SPAN>, vol.32, no.2, p.109-143
(junio de 2000).
<P></P><DT><A NAME="key-19">19</A>
<DD>Davidson, Clive. ``Creatures from primordial silicon.'' <SPAN  CLASS="textit">New
Scientist</SPAN>, vol.156, no.2.108, p.30-35 (15 de noviembre de 1997).
Disponible <a href="http://www.newscientist.com/hottopics/ai/primordial.jsp">en l&#237;nea</a>.
<P></P><DT><A NAME="key-20">20</A>
<DD>Dawkins, Richard. <SPAN  CLASS="textit">The Blind Watchmaker: Why the Evidence of
Evolution Reveals a Universe Without Design</SPAN>. W.W. Norton, 1996.
<P></P><DT><A NAME="key-21">21</A>
<DD>Dembski, William. <SPAN  CLASS="textit">No Free Lunch: Why Specified Complexity Cannot
Be Purchased Without Intelligence</SPAN>. Rowman &amp; Littlefield, 2002.
<P></P><DT><A NAME="key-22">22</A>
<DD>Fleming, Peter y R.C. Purshouse. ``Evolutionary algorithms in control
systems engineering: a survey.'' <SPAN  CLASS="textit">Control Engineering Practice</SPAN>,
vol.10, p.1.223-1.241 (2002).
<P></P><DT><A NAME="key-23">23</A>
<DD>Fonseca, Carlos y Peter Fleming. ``An overview of evolutionary algorithms
in multiobjective optimization.'' <SPAN  CLASS="textit">Evolutionary Computation</SPAN>,
vol.3, no.1, p.1-16 (1995). 
<P></P><DT><A NAME="key-24">24</A>
<DD>Forrest, Stephanie. ``Genetic algorithms: principles of natural selection
applied to computation.'' <SPAN  CLASS="textit">Science</SPAN>, vol.261, p.872-878 (1993).
<P></P><DT><A NAME="key-25">25</A>
<DD>Gibbs, W. Wayt. ``Programming with primordial ooze.'' <SPAN  CLASS="textit">Scientific
American</SPAN>, octubre de 1996, p.48-50.
<P></P><DT><A NAME="key-26">26</A>
<DD>Gillet, Valerie. ``Reactant- and product-based approaches to the design
of combinatorial libraries.'' <SPAN  CLASS="textit">Journal of Computer-Aided Molecular
Design</SPAN>, vol.16, p.371-380 (2002).
<P></P><DT><A NAME="key-27">27</A>
<DD>Giro, R., M. Cyrillo y D.S. Galv&#227;o. ``Designing conducting polymers
using genetic algorithms.'' <SPAN  CLASS="textit">Chemical Physics Letters</SPAN>, vol.366,
no.1-2, p.170-175 (25 de noviembre de 2002).
<P></P><DT><A NAME="key-28">28</A>
<DD>Glen, R.C. y A.W.R. Payne. ``A genetic algorithm for the automated
generation of molecules within constraints.'' <SPAN  CLASS="textit">Journal of Computer-Aided
Molecular Design</SPAN>, vol.9, p.181-202 (1995).
<P></P><DT><A NAME="key-29">29</A>
<DD>Goldberg, David. <SPAN  CLASS="textit">Genetic Algorithms in Search, Optimization,
and Machine Learning</SPAN>. Addison-Wesley, 1989.
<P></P><DT><A NAME="key-30">30</A>
<DD>Graham-Rowe, Duncan. ``Radio emerges from the electronic soup.'' <SPAN  CLASS="textit">New
Scientist</SPAN>, vol.175, no.2.358, p.19 (31 de agosto de 2002). Disponible
<a href="http://www.newscientist.com/news/news.jsp?id=ns99992732">en l&#237;nea</a>
<BR>
<BR>Ver tambi&#233;n: Bird, Jon y Paul Layzell. ``The evolved radio and its
implications for modelling the evolution of novel sensors.'' En <SPAN  CLASS="textit">Proceedings
of the 2002 Congress on Evolutionary Computation</SPAN>, p.1.836-1.841.
<P></P><DT><A NAME="key-31">31</A>
<DD>Graham-Rowe, Duncan. ``Electronic circuit 'evolves' from liquid crystals.''
<SPAN  CLASS="textit">New Scientist</SPAN>, vol.181, no.2.440, p.21 (27 de marzo de 2004).
<P></P><DT><A NAME="key-32">32</A>
<DD>Haas, O.C.L., K.J. Burnham y J.A. Mills. ``On improving physical selectivity
in the treatment of cancer: A systems modelling and optimisation approach.''
<SPAN  CLASS="textit">Control Engineering Practice</SPAN>, vol.5, no.12, p.1.739-1.745 (diciembre
de 1997).
<P></P><DT><A NAME="key-33">33</A>
<DD>Hanne, Thomas. ``Global multiobjective optimization using evolutionary
algorithms.'' <SPAN  CLASS="textit">Journal of Heuristics</SPAN>, vol.6, no.3, p.347-360
(agosto de 2000).
<P></P><DT><A NAME="key-34">34</A>
<DD>Haupt, Randy y Sue Ellen Haupt. <SPAN  CLASS="textit">Practical Genetic Algorithms</SPAN>.
John Wiley &amp; Sons, 1998.
<P></P><DT><A NAME="key-35">35</A>
<DD>He, L. y N. Mort. ``Hybrid genetic algorithms for telecommunications
network back-up routeing.'' <SPAN  CLASS="textit">BT Technology Journa</SPAN>l, vol.18,
no.4, p. 42-50 (octubre de 2000).
<P></P><DT><A NAME="key-36">36</A>
<DD>Holland, John. ``Genetic algorithms.'' <SPAN  CLASS="textit">Scientific American</SPAN>,
julio de 1992, p. 66-72.
<P></P><DT><A NAME="key-37">37</A>
<DD>Hughes, Evan y Maurice Leyland. ``Using multiple genetic algorithms
to generate radar point-scatterer models.'' <SPAN  CLASS="textit">IEEE Transactions
on Evolutionary Computation</SPAN>, vol.4, no.2, p.147-163 (julio de 2000).
<P></P><DT><A NAME="key-38">38</A>
<DD>Jensen, Mikkel. ``Generating robust and flexible job shop schedules
using genetic algorithms.'' <SPAN  CLASS="textit">IEEE Transactions on Evolutionary
Computation</SPAN>, vol.7, no.3, p.275-288 (junio de 2003).
<P></P><DT><A NAME="key-39">39</A>
<DD>Kewley, Robert y Mark Embrechts. ``Computational military tactical
planning system.'' <SPAN  CLASS="textit">IEEE Transactions on Systems, Man and Cybernetics,
Part C - Applications and Reviews</SPAN>, vol.32, no.2, p.161-171 (mayo
de 2002).
<P></P><DT><A NAME="key-40">40</A>
<DD>Kirkpatrick, S., C.D. Gelatt y M.P. Vecchi. ``Optimization by simulated
annealing.'' <SPAN  CLASS="textit">Science</SPAN>, vol.220, p.671-678 (1983).
<P></P><DT><A NAME="key-41">41</A>
<DD>Koza, John, Forest Bennett, David Andre y Martin Keane. <SPAN  CLASS="textit">Genetic
Programming III: Darwinian Invention and Problem Solving</SPAN>. Morgan
Kaufmann Publishers, 1999.
<P></P><DT><A NAME="key-42">42</A>
<DD>Koza, John, Martin Keane, Matthew Streeter, William Mydlowec, Jessen
Yu y Guido Lanza. <SPAN  CLASS="textit">Genetic Programming IV: Routine Human-Competitive
Machine Intelligence</SPAN>. Kluwer Academic Publishers, 2003.
<BR>
<BR>Ver tambi&#233;n: Koza, John, Martin Keane y Matthew Streeter. ``Evolving
inventions.'' <SPAN  CLASS="textit">Scientific American</SPAN>, febrero de 2003, p. 52-59.
<P></P><DT><A NAME="key-43">43</A>
<DD>Keane, A.J. y S.M. Brown. ``The design of a satellite boom with enhanced
vibration performance using genetic algorithm techniques.'' En <SPAN  CLASS="textit">Adaptive
Computing in Engineering Design and Control '96 - Proceedings of the
Second International Conference</SPAN>, I.C. Parmee (ed), p.107-113. University
of Plymouth, 1996.
<BR>
<BR>Ver tambi&#233;n: Petit, Charles. ``Touched by nature: Putting evolution
to work on the assembly line.'' <SPAN  CLASS="textit">U.S. News and World Report</SPAN>,
vol.125, no.4, p.43-45 (27 de julio de 1998). Disponible <a href="http://www.genetic-programming.com/published/usnwr072798.html">en l&#237;nea</a>.
<P></P><DT><A NAME="key-44">44</A>
<DD>Lee, Yonggon y Stanislaw H. Zak. ``Designing a genetic neural fuzzy
antilock-brake-system controller.'' <SPAN  CLASS="textit">IEEE Transactions on Evolutionary
Computation</SPAN>, vol.6, no.2, p.198-211 (abril de 2002).
<P></P><DT><A NAME="key-45">45</A>
<DD>Lemley, Brad. ``Machines that think.'' <SPAN  CLASS="textit">Discover</SPAN>, enero de 2001,
p.75-79.
<P></P><DT><A NAME="key-46">46</A>
<DD>Mahfoud, Sam y Ganesh Mani. ``Financial forecasting using genetic
algorithms.'' <SPAN  CLASS="textit">Applied Artificial Intelligence</SPAN>, vol.10, no.6,
p.543-565 (1996).
<P></P><DT><A NAME="key-47">47</A>
<DD>Mitchell, Melanie. <SPAN  CLASS="textit">An Introduction to Genetic Algorithms</SPAN>. MIT
Press, 1996.
<P></P><DT><A NAME="key-48">48</A>
<DD>Naik, Gautam. ``Back to Darwin: In sunlight and cells, science seeks
answers to high-tech puzzles.'' <SPAN  CLASS="textit">The Wall Street Journal</SPAN>, 16
de enero de 1996, p. A1.
<P></P><DT><A NAME="key-49">49</A>
<DD>Obayashi, Shigeru, Daisuke Sasaki, Yukihiro Takeguchi, y Naoki Hirose.
``Multiobjective evolutionary computation for supersonic wing-shape
optimization.'' <SPAN  CLASS="textit">IEEE Transactions on Evolutionary Computation</SPAN>,
vol.4, no.2, p.182-187 (julio de 2000).
<P></P><DT><A NAME="key-50">50</A>
<DD>Petzinger, Thomas. ``At Deere they know a mad scientist may be a firm's
biggest asset.'' <SPAN  CLASS="textit">The Wall Street Journal</SPAN>, 14 de julio de 1995,
p.B1.
<BR>
<BR>Ver tambi&#233;n: ``Evolving business, with a Santa Fe Institute twist.''
<SPAN  CLASS="textit">SFI Bulletin</SPAN>, invierno de 1998. Disponible
<a href="http://www.santafe.edu/sfi/publications/Bulletins/bulletin-winter98/feature.html">en l&#237;nea</a>.
<P></P><DT><A NAME="key-51">51</A>
<DD>Porto, Vincent, David Fogel y Lawrence Fogel. ``Alternative neural
network training methods.'' <SPAN  CLASS="textit">IEEE Expert</SPAN>, vol.10, no.3, p.16-22
(junio de 1995).
<P></P><DT><A NAME="key-52">52</A>
<DD>Rao, Srikumar. ``Evolution at warp speed.'' <SPAN  CLASS="textit">Forbes</SPAN>, vol.161,
no.1, p.82-83 (12 de enero de 1998).
<P></P><DT><A NAME="key-53">53</A>
<DD>Rizki, Mateen, Michael Zmuda y Louis Tamburino. ``Evolving pattern
recognition systems.'' <SPAN  CLASS="textit">IEEE Transactions on Evolutionary Computation</SPAN>,
vol.6, no.6, p.594-609 (diciembre de 2002).
<P></P><DT><A NAME="key-54">54</A>
<DD>Robin, Franck, Andrea Orzati, Esteban Moreno, Otte Homan, y Werner
Bachtold. ``Simulation and evolutionary optimization of electron-beam
lithography with genetic and simplex-downhill algorithms.'' <SPAN  CLASS="textit">IEEE
Transactions on Evolutionary Computation</SPAN>, vol.7, no.1, p.69-82 (febrero
de 2003).
<P></P><DT><A NAME="key-55">55</A>
<DD>Sagan, Carl. <SPAN  CLASS="textit">Broca's Brain: Reflections on the Romance of Science</SPAN>.
Ballantine, 1979.
<P></P><DT><A NAME="key-56">56</A>
<DD>Sambridge, Malcolm y Kerry Gallagher. ``Earthquake hypocenter location
using genetic algorithms.'' <SPAN  CLASS="textit">Bulletin of the Seismological Society
of America</SPAN>, vol.83, no.5, p.1.467-1.491 (octubre de 1993).
<P></P><DT><A NAME="key-57">57</A>
<DD>Sasaki, Daisuke, Masashi Morikawa, Shigeru Obayashi y Kazuhiro Nakahashi.
``Aerodynamic shape optimization of supersonic wings by adaptive range
multiobjective genetic algorithms.'' En <SPAN  CLASS="textit">Evolutionary Multi-Criterion
Optimization: First International Conference, EMO 2001, Zurich, Switzerland,
March 2001: Proceedings</SPAN>, K. Deb, L. Theile, C. Coello, D. Corne y
E. Zitler (eds). Notas de la confenrencia en <SPAN  CLASS="textit">Computer Science</SPAN>,
vol.1993, p.639-652. Springer-Verlag, 2001.
<P></P><DT><A NAME="key-58">58</A>
<DD>Sato, S., K. Otori, A. Takizawa, H. Sakai, Y. Ando y H. Kawamura.
``Applying genetic algorithms to the optimum design of a concert hall.''
<SPAN  CLASS="textit">Journal of Sound and Vibration</SPAN>, vol.258, no.3, p. 517-526 (2002).
<P></P><DT><A NAME="key-59">59</A>
<DD>Schechter, Bruce. ``Putting a Darwinian spin on the diesel engine.''
<SPAN  CLASS="textit">The New York Times</SPAN>, 19 de septiembre de 2000, p. F3.
<BR>
<BR>Ver tambi&#233;n: Patch, Kimberly. ``Algorithm evolves more efficient engine.''
<SPAN  CLASS="textit">Technology Research News</SPAN>, junio/julio de 2000. Disponible
<a href="http://www.trnmag.com/Stories/062800/Genetically_Enhanced_Engine_062800.html">en
l&#237;nea</a>.
<P></P><DT><A NAME="key-60">60</A>
<DD>Srinivas, N. y Kalyanmoy Deb. ``Multiobjective optimization using
nondominated sorting in genetic algorithms.'' <SPAN  CLASS="textit">Evolutionary Computation</SPAN>,
vol.2, no.3, p.221-248 (oto&#241;o de 1994).
<P></P><DT><A NAME="key-61">61</A>
<DD>Soule, Terrence y Amy Ball. ``A genetic algorithm with multiple reading
frames.'' En <SPAN  CLASS="textit">GECCO-2001: Proceedings of the Genetic and Evolutionary
Computation Conference</SPAN>, Lee Spector y Eric Goodman (eds). Morgan
Kaufmann, 2001. Disponible <a href="http://www.cs.uidaho.edu/tsoule/research/papers.html">en l&#237;nea</a>.
<P></P><DT><A NAME="key-62">62</A>
<DD>Tang, K.S., K.F. Man, S. Kwong y Q. He. ``Genetic algorithms and their
applications.'' <SPAN  CLASS="textit">IEEE Signal Processing Magazine</SPAN>, vol.13, no.6,
p.22-37 (noviembre de 1996).
<P></P><DT><A NAME="key-63">63</A>
<DD>Weismann, Dirk, Ulrich Hammel, y Thomas B&#228;ck. ``Robust design of multilayer
optical coatings by means of evolutionary algorithms.'' <SPAN  CLASS="textit">IEEE
Transactions on Evolutionary Computation</SPAN>, vol.2, no.4, p.162-167
(noviembre de 1998).
<P></P><DT><A NAME="key-64">64</A>
<DD>Williams, Edwin, William Crossley y Thomas Lang. ``Average and maximum
revisit time trade studies for satellite constellations using a multiobjective
genetic algorithm.'' <SPAN  CLASS="textit">Journal of the Astronautical Sciences</SPAN>,
vol.49, no.3, p.385-400 (julio-septiembre de 2001).
<BR>
<BR>Ver tambi&#233;n: ``Selecting better orbits for satellite constellations.''
<a href="http://spaceflightnow.com">Spaceflight Now</a>, 18 de octubre de
2001. Disponible <a href="http://spaceflightnow.com/news/n0110/18orbits/">en l&#237;nea</a>.
<BR>
<BR>``Darwinian selection of satellite orbits for military use.'' <a href="http://space.com">Space.com</a>,
16 de octubre de 2001. Disponible <a href="http://www.space.com/news/darwin_satellites_011016.html">en l&#237;nea</a>.
<P></P><DT><A NAME="key-65">65</A>
<DD>Zitzler, Eckart y Lothar Thiele. ``Multiobjective evolutionary algorithms:
a comparative case study and the Strength Pareto approach.'' <SPAN  CLASS="textit">IEEE
Transactions on Evolutionary Computation</SPAN>, vol.3, no.4, p.257-271
(noviembre de 1999).</DL>

<P>

<H1><A NAME="SECTION000100000000000000000">
About this document ...</A>
</H1>
 <STRONG>Algoritmos gen&#233;ticos y computaci&#243;n evolutiva</STRONG><P>
This document was generated using the
<A HREF="http://www.latex2html.org/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 2002-2-1 (1.70)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
<A HREF="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos Drakos</A>, 
Computer Based Learning Unit, University of Leeds.
<BR>Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-split 0 -local_icons -up_url http://the-geek.org/docs algen.tex</TT>
<P>
Traducción realizada por Gabriel Rodríguez Alberich.<BR>
El <a href="http://www.talkorigins.org/faqs/genalg/genalg.html">documento original</a> se encuentra en la página web de
<a href="http://www.talkorigins.org/">Talk.Origins</a>.
<HR><H4>Notas al pie</H4>

<DL>
<DT><A NAME="foot204">...</A><A
 HREF="algen.html#tex2html6"><SUP><SPAN CLASS="arabic">1</SPAN></SUP></A></DT>
<DD>En inglés ``churn'', término de difícil traducción.

</DD>
</DL>
<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive" SRC="nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev_g.png">   
<BR></DIV>
<!--End of Navigation Panel-->
<ADDRESS>
Gabriel Rodríguez Alberich
2004-10-22
</ADDRESS>
</BODY>
</HTML>
